diff --git a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/cjs/index.d.ts b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/cjs/index.d.ts
index f87764a..cdeb8c0 100644
--- a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/cjs/index.d.ts
+++ b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/cjs/index.d.ts
@@ -2478,7 +2478,7 @@ declare class Dragging extends StateNode {
     private complete;
 }
 
-declare class DraggingHandle extends StateNode {
+export declare class DraggingHandle extends StateNode {
     static id: string;
     shapeId: TLShapeId;
     initialHandle: TLHandle;
@@ -4066,46 +4066,46 @@ declare class TickManager {
 /** @public */
 export declare const TLArrowShapeDef: TLShapeDef<TLArrowShape, TLArrowUtil>;
 
-declare class TLArrowTool extends StateNode {
+export declare class TLArrowTool extends StateNode {
     static id: string;
     static initial: string;
-    static children: () => (typeof Idle | typeof Pointing)[];
+    static children: () => [typeof Idle, typeof Pointing];
     shapeType: TLShapeType;
     styles: ("color" | "fill" | "dash" | "size" | "opacity" | "font" | "align" | "geo" | "arrowheadStart" | "arrowheadEnd" | "spline" | "icon" | "labelColor")[];
 }
 
 /** @public */
-export declare class TLArrowUtil extends TLShapeUtil<TLArrowShape> {
+export declare class TLArrowUtil<Shape extends TLArrowShape> extends TLShapeUtil<Shape> {
     static type: string;
     canEdit: () => boolean;
     canBind: () => boolean;
     isClosed: () => boolean;
-    hideResizeHandles: TLShapeUtilFlag<TLArrowShape>;
-    hideRotateHandle: TLShapeUtilFlag<TLArrowShape>;
-    hideSelectionBoundsFg: TLShapeUtilFlag<TLArrowShape>;
-    hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape>;
-    defaultProps(): TLArrowShape['props'];
-    getCenter(shape: TLArrowShape): Vec2d;
-    getBounds(shape: TLArrowShape): Box2d;
-    getOutlineWithoutLabel(shape: TLArrowShape): VecLike[];
-    getOutline(shape: TLArrowShape): Vec2dModel[];
-    snapPoints(_shape: TLArrowShape): Vec2d[];
+    hideResizeHandles: TLShapeUtilFlag<Shape>;
+    hideRotateHandle: TLShapeUtilFlag<Shape>;
+    hideSelectionBoundsFg: TLShapeUtilFlag<Shape>;
+    hideSelectionBoundsBg: TLShapeUtilFlag<Shape>;
+    defaultProps(): Shape['props'];
+    getCenter(shape: Shape): Vec2d;
+    getBounds(shape: Shape): Box2d;
+    getOutlineWithoutLabel(shape: Shape): VecLike[];
+    getOutline(shape: Shape): Vec2dModel[];
+    snapPoints(_shape: Shape): Vec2d[];
     private get infoCache();
-    getArrowInfo(shape: TLArrowShape): ArrowInfo | undefined;
-    getHandles(shape: TLArrowShape): TLHandle[];
-    onHandleChange: OnHandleChangeHandler<TLArrowShape>;
-    onTranslateStart: OnTranslateStartHandler<TLArrowShape>;
-    onResize: OnResizeHandler<TLArrowShape>;
-    onDoubleClickHandle: (shape: TLArrowShape, handle: TLHandle) => TLShapePartial<TLArrowShape> | void;
-    hitTestPoint(shape: TLArrowShape, point: VecLike): boolean;
-    hitTestLineSegment(shape: TLArrowShape, A: VecLike, B: VecLike): boolean;
-    render(shape: TLArrowShape): JSX.Element | null;
-    indicator(shape: TLArrowShape): JSX.Element | null;
-    get labelBoundsCache(): ComputedCache<Box2d | null, TLArrowShape>;
-    getLabelBounds(shape: TLArrowShape): Box2d | null;
-    getEditingBounds: (shape: TLArrowShape) => Box2d;
-    onEditEnd: OnEditEndHandler<TLArrowShape>;
-    toSvg(shape: TLArrowShape, font: string, colors: TLExportColors): SVGGElement;
+    getArrowInfo(shape: Shape): ArrowInfo | undefined;
+    getHandles(shape: Shape): TLHandle[];
+    onHandleChange: OnHandleChangeHandler<Shape>;
+    onTranslateStart: OnTranslateStartHandler<Shape>;
+    onResize: OnResizeHandler<Shape>;
+    onDoubleClickHandle: (shape: Shape, handle: TLHandle) => TLShapePartial<Shape> | void;
+    hitTestPoint(shape: Shape, point: VecLike): boolean;
+    hitTestLineSegment(shape: Shape, A: VecLike, B: VecLike): boolean;
+    render(shape: Shape): JSX.Element | null;
+    indicator(shape: Shape): JSX.Element | null;
+    get labelBoundsCache(): ComputedCache<Box2d | null, Shape>;
+    getLabelBounds(shape: Shape): Box2d | null;
+    getEditingBounds: (shape: Shape) => Box2d;
+    onEditEnd: OnEditEndHandler<Shape>;
+    toSvg(shape: Shape, font: string, colors: TLExportColors): SVGGElement;
 }
 
 /** @public */
@@ -4806,7 +4806,7 @@ export declare type TLResizeMode = 'scale_shape' | 'resize_bounds';
 /** @public */
 export declare type TLSelectionHandle = SelectionCorner | SelectionEdge | RotateCorner;
 
-declare class TLSelectTool extends StateNode {
+export declare class TLSelectTool extends StateNode {
     static id: string;
     static initial: string;
     static children: () => (typeof Resizing | typeof Translating | typeof Brushing | typeof DraggingHandle | typeof EditingShape | typeof Idle_9 | typeof PointingCanvas | typeof PointingHandle | typeof PointingResizeHandle | typeof PointingRotateHandle | typeof PointingSelection | typeof PointingShape | typeof Rotating | typeof ScribbleBrushing)[];
diff --git a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/app/App.mjs b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/app/App.mjs
index 41f58f9..7b156c0 100644
--- a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/app/App.mjs
+++ b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/app/App.mjs
@@ -2827,7 +2827,28 @@ const _App = class extends EventEmitter {
         newShape.index = index;
         index = getIndexAbove(index);
       }
-      if (TLArrowShapeDef.is(newShape)) {
+
+      // for copy and pasting custom arrows to a new canvas
+      // after migrating to newest tldraw, use isShapeOfType
+      // https://github.com/tldraw/tldraw/blob/ed37bcf54126201f4e1915f25845a623ad6c5174/packages/editor/src/lib/editor/Editor.ts#L7633-L7701
+      // or new API for bindings if available
+      // https://discord.com/channels/859816885297741824/926464446694580275/1190596833349742622
+      const initialStartBindingId =
+      shape?.props?.start?.type === "binding"
+        ? shape.props.start.boundShapeId
+        : undefined;
+      const initialEndBindingId =
+      shape?.props?.end?.type === "binding"
+        ? shape.props.end.boundShapeId
+        : undefined;
+
+      const startBindingShape = shapes.find((s) => s.id === initialStartBindingId);
+      const endBindingShape = shapes.find((s) => s.id === initialEndBindingId);
+
+      const hasCopiedBindingShape =
+      startBindingShape !== undefined || endBindingShape !== undefined;
+
+      if (TLArrowShapeDef.is(newShape) || hasCopiedBindingShape) {
         if (newShape.props.start.type === "binding") {
           const mappedId = idMap.get(newShape.props.start.boundShapeId);
           newShape.props.start = mappedId ? { ...newShape.props.start, boundShapeId: mappedId } : (
diff --git a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/app/App.mjs.map b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/app/App.mjs.map
deleted file mode 100644
index c191db3..0000000
--- a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/app/App.mjs.map
+++ /dev/null
@@ -1,7 +0,0 @@
-{
-  "version": 3,
-  "sources": ["../../../../src/lib/app/App.ts"],
-  "sourcesContent": ["import {\n\tapproximately,\n\tareAnglesCompatible,\n\tBox2d,\n\tclamp,\n\tEASINGS,\n\tintersectPolygonPolygon,\n\tMatLike,\n\tMatrix2d,\n\tMatrix2dModel,\n\tPI2,\n\tpointInPolygon,\n\tVec2d,\n\tVecLike,\n} from '@tldraw/primitives'\nimport {\n\tBox2dModel,\n\tcreateCustomShapeId,\n\tcreateShapeId,\n\tisShape,\n\tisShapeId,\n\tTLArrowShape,\n\tTLArrowTerminal,\n\tTLAsset,\n\tTLAssetId,\n\tTLAssetPartial,\n\tTLCamera,\n\tTLColorStyle,\n\tTLColorType,\n\tTLCursor,\n\tTLCursorType,\n\tTLDOCUMENT_ID,\n\tTLFrameShape,\n\tTLGroupShape,\n\tTLImageAsset,\n\tTLInstance,\n\tTLInstanceId,\n\tTLInstancePageState,\n\tTLNullableShapeProps,\n\tTLPage,\n\tTLPageId,\n\tTLParentId,\n\tTLRecord,\n\tTLScribble,\n\tTLShape,\n\tTLShapeId,\n\tTLShapePartial,\n\tTLShapeProp,\n\tTLShapeType,\n\tTLSizeStyle,\n\tTLStore,\n\tTLUnknownShape,\n\tTLUser,\n\tTLUserDocument,\n\tTLUserId,\n\tTLVideoAsset,\n\tVec2dModel,\n} from '@tldraw/tlschema'\nimport { ComputedCache, HistoryEntry } from '@tldraw/tlstore'\nimport { annotateError, compact, dedupe, deepCopy, structuredClone } from '@tldraw/utils'\nimport { EventEmitter } from 'eventemitter3'\nimport { atom, computed, EMPTY_ARRAY, transact } from 'signia'\nimport { TldrawEditorConfig } from '../config/TldrawEditorConfig'\nimport { TLShapeDef } from '../config/TLShapeDefinition'\nimport {\n\tANIMATION_MEDIUM_MS,\n\tDEFAULT_ANIMATION_OPTIONS,\n\tDIRECTION_DELTAS,\n\tDRAG_DISTANCE,\n\tGRID_INCREMENT,\n\tHAND_TOOL_FRICTION,\n\tMAJOR_NUDGE_FACTOR,\n\tMAX_PAGES,\n\tMAX_SHAPES_PER_PAGE,\n\tMAX_ZOOM,\n\tMIN_ZOOM,\n\tMINOR_NUDGE_FACTOR,\n\tSTYLES,\n\tSVG_PADDING,\n\tZOOMS,\n} from '../constants'\nimport { exportPatternSvgDefs } from '../hooks/usePattern'\nimport {\n\tapplyRotationToSnapshotShapes,\n\tdataUrlToFile,\n\tgetIncrementedName,\n\tgetIndexAbove,\n\tgetIndexBetween,\n\tgetIndices,\n\tgetIndicesAbove,\n\tgetIndicesBetween,\n\tgetMediaAssetFromFile,\n\tgetRotationSnapshot,\n\tsetPropsForNextShape,\n\tsortById,\n\tsortByIndex,\n\tuniqueId,\n\tWeakMapCache,\n} from '../utils'\nimport { arrowBindingsIndex } from './derivations/arrowBindingsIndex'\nimport { parentsToChildrenWithIndexes } from './derivations/parentsToChildrenWithIndexes'\nimport { shapeIdsInCurrentPage } from './derivations/shapeIdsInCurrentPage'\nimport {\n\tActiveAreaManager,\n\tCameraManager,\n\tClickManager,\n\tDprManager,\n\tgetActiveAreaScreenSpace,\n\tHistoryManager,\n\tSnapManager,\n\tTextManager,\n\tTickManager,\n} from './managers'\nimport {\n\tTLArrowShapeDef,\n\tTLGroupShapeDef,\n\tTLResizeMode,\n\tTLShapeUtil,\n\tTLTextShapeDef,\n} from './shapeutils'\nimport { TLExportColors } from './shapeutils/shared'\nimport { getArrowTerminalsInArrowSpace } from './shapeutils/TLArrowUtil/arrow/shared'\nimport { TLFrameShapeDef } from './shapeutils/TLFrameUtil/TLFrameUtil'\nimport { RootState } from './statechart/RootState'\nimport { StateNode } from './statechart/StateNode'\nimport { TLClipboardModel } from './types/clipboard-types'\nimport { TLEventInfo, TLPinchEventInfo, TLPointerEventInfo } from './types/event-types'\nimport { RequiredKeys, TLDeltaDirection } from './types/misc-types'\nimport { TLReorderOperation } from './types/reorder-types'\nimport { TLResizeHandle } from './types/selection-types'\n\n/** @public */\nexport type TLChange = HistoryEntry<any>\n\n/** @public */\nexport type AnimationOptions = Partial<{\n\tduration: number\n\teasing: typeof EASINGS.easeInOutCubic\n}>\n\n/** @public */\nexport interface AppOptions {\n\t/**\n\t * The Store instance to use for keeping the app's data.\n\t * This may be prepopulated, e.g. by loading from a server or database.\n\t */\n\tstore: TLStore\n\t/**\n\t * A configuration defining major customizations to the app, such as custom\n\t * shapes and new tools\n\t */\n\tconfig?: TldrawEditorConfig\n\t/**\n\t * Should the App be displayed in readonly mode?\n\t */\n\treadonly?: boolean\n\t/**\n\t * Should return a containing html element which has all the styles applied to the app.\n\t * If not given, the body element will be used.\n\t */\n\tgetContainer: () => HTMLElement\n\n\t/**\n\t * The id of the current user. If not given, one will be generated.\n\t */\n\tuserId?: TLUserId\n\t/**\n\t * The id of the app instance (e.g. a browser tab if the app will have only one tldraw app per tab).\n\t * If not given, one will be generated.\n\t */\n\tinstanceId?: TLInstanceId\n}\n\n/** @public */\nexport function isShapeWithHandles(shape: TLShape) {\n\treturn shape.type === 'arrow' || shape.type === 'line' || shape.type === 'draw'\n}\n\n/** @public */\nexport class App extends EventEmitter {\n\tconstructor({ config = TldrawEditorConfig.default, readonly, store, getContainer }: AppOptions) {\n\t\tsuper()\n\n\t\tif (store.schema !== config.storeSchema) {\n\t\t\tthrow new Error('Store schema does not match schema given to App')\n\t\t}\n\n\t\tthis.config = config\n\t\tthis.store = store\n\n\t\tthis.getContainer = getContainer ?? (() => document.body)\n\n\t\tthis.textMeasure = new TextManager(this)\n\n\t\t// Set the shape utils\n\t\tthis.shapeUtils = Object.fromEntries(\n\t\t\tconfig.shapes.map((def) => [\n\t\t\t\tdef.type,\n\t\t\t\tdef.createShapeUtils(this) as TLShapeUtil<TLUnknownShape>,\n\t\t\t])\n\t\t)\n\n\t\tif (typeof window !== 'undefined') {\n\t\t\tthis.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n\t\t}\n\n\t\tif (typeof window !== 'undefined') {\n\t\t\tthis.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i)\n\t\t}\n\n\t\t// Set styles\n\t\tthis.colors = new Map(App.styles.color.map((c) => [c.id, `var(--palette-${c.id})`]))\n\n\t\tthis.root = new RootState(this)\n\t\tif (this.root.children) {\n\t\t\tconfig.tools.forEach((Ctor) => {\n\t\t\t\tthis.root.children![Ctor.id] = new Ctor(this)\n\t\t\t})\n\t\t}\n\n\t\tthis.store.onBeforeDelete = (record) => {\n\t\t\tif (record.typeName === 'shape') {\n\t\t\t\tthis._shapeWillBeDeleted(record)\n\t\t\t} else if (record.typeName === 'page') {\n\t\t\t\tthis._pageWillBeDeleted(record)\n\t\t\t}\n\t\t}\n\n\t\tthis.store.onAfterChange = (prev, next) => {\n\t\t\tthis.updateDepth++\n\t\t\tif (this.updateDepth > 1000) {\n\t\t\t\tconsole.error('[onAfterChange] Maximum update depth exceeded, bailing out.')\n\t\t\t}\n\t\t\tif (prev.typeName === 'shape' && next.typeName === 'shape') {\n\t\t\t\tthis._shapeDidChange(prev, next)\n\t\t\t} else if (\n\t\t\t\tprev.typeName === 'instance_page_state' &&\n\t\t\t\tnext.typeName === 'instance_page_state'\n\t\t\t) {\n\t\t\t\tthis._tabStateDidChange(prev, next)\n\t\t\t}\n\n\t\t\tthis.updateDepth--\n\t\t}\n\t\tthis.store.onAfterCreate = (record) => {\n\t\t\tif (record.typeName === 'shape' && TLArrowShapeDef.is(record)) {\n\t\t\t\tthis._arrowDidUpdate(record)\n\t\t\t}\n\t\t}\n\n\t\tthis._shapeIds = shapeIdsInCurrentPage(this.store, () => this.currentPageId)\n\t\tthis._parentsToChildrenWithIndexes = parentsToChildrenWithIndexes(this.store)\n\n\t\tthis.disposables.add(\n\t\t\tthis.store.listen((changes) => {\n\t\t\t\tthis.emit('change', changes as TLChange)\n\t\t\t})\n\t\t)\n\n\t\tthis.store.ensureStoreIsUsable()\n\n\t\tthis.root.enter(undefined, 'initial')\n\n\t\tthis.updateCullingViewport()\n\n\t\trequestAnimationFrame(() => {\n\t\t\tthis._tickManager.start()\n\t\t})\n\n\t\tif (readonly) {\n\t\t\tthis.updateUserDocumentSettings({\n\t\t\t\tisReadOnly: readonly,\n\t\t\t})\n\t\t}\n\n\t\tif (this.userDocumentSettings.isReadOnly) {\n\t\t\tthis.setSelectedTool('hand')\n\t\t}\n\t}\n\n\tprivate updateDepth = 0\n\n\treadonly disposables = new Set<() => void>()\n\n\tget userId(): TLUserId {\n\t\treturn this.store.props.userId\n\t}\n\tget instanceId(): TLInstanceId {\n\t\treturn this.store.props.instanceId\n\t}\n\n\tisSafari = false\n\n\tisIos = false\n\n\t_dprManager = new DprManager(this)\n\n\t_cameraManager = new CameraManager(this)\n\n\t_activeAreaManager = new ActiveAreaManager(this)\n\n\t_tickManager = new TickManager(this)\n\n\tgetContainer: () => HTMLElement\n\n\t/** @internal */\n\tannotateError(\n\t\terror: unknown,\n\t\t{\n\t\t\torigin,\n\t\t\twillCrashApp,\n\t\t\ttags,\n\t\t\textras,\n\t\t}: {\n\t\t\torigin: string\n\t\t\twillCrashApp: boolean\n\t\t\ttags?: Record<string, string | boolean | number>\n\t\t\textras?: Record<string, unknown>\n\t\t}\n\t) {\n\t\tconst defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp)\n\t\tannotateError(error, {\n\t\t\ttags: { ...defaultAnnotations.tags, ...tags },\n\t\t\textras: { ...defaultAnnotations.extras, ...extras },\n\t\t})\n\t\tif (willCrashApp) {\n\t\t\tthis.store.markAsPossiblyCorrupted()\n\t\t}\n\t}\n\n\t/** @internal */\n\tcreateErrorAnnotations(origin: string, willCrashApp: boolean | 'unknown') {\n\t\treturn {\n\t\t\ttags: {\n\t\t\t\torigin: origin,\n\t\t\t\twillCrashApp,\n\t\t\t},\n\t\t\textras: {\n\t\t\t\tactiveStateNode: this.root.path.value,\n\t\t\t\tselectedShapes: this.selectedShapes,\n\t\t\t\teditingShape: this.editingId ? this.getShapeById(this.editingId) : null,\n\t\t\t\tinputs: this.inputs,\n\t\t\t},\n\t\t}\n\t}\n\n\tprivate _crashingError: unknown | null = null\n\t/**\n\t * we can't use an `atom` here because there's a chance that when\n\t * `crashAndReportError` is called, we're in a transaction that's about to\n\t * be rolled back due to the same error we're currently reporting.\n\t *\n\t * instead, to listen to changes to this value, you need to listen to app's\n\t * `crash` event.\n\t *\n\t * @internal\n\t */\n\tget crashingError() {\n\t\treturn this._crashingError\n\t}\n\t/** @internal */\n\tcrash(error: unknown) {\n\t\tthis._crashingError = error\n\t\tthis.store.markAsPossiblyCorrupted()\n\t\tthis.emit('crash')\n\t}\n\n\tget devicePixelRatio() {\n\t\treturn this._dprManager.dpr.value\n\t}\n\n\topenMenus = new Set<string>()\n\n\tget isMenuOpen() {\n\t\treturn this.openMenus.size > 0\n\t}\n\n\t/**\n\t * Whether the context menu is open. When open, pointer up events are ignored.\n\t *\n\t * @public\n\t */\n\tget isCoarsePointer() {\n\t\treturn this._isCoarsePointer.value\n\t}\n\n\tset isCoarsePointer(v) {\n\t\tthis._isCoarsePointer.set(v)\n\t}\n\n\tprivate _isCoarsePointer = atom<boolean>('isCoarsePointer', false as any)\n\n\t@computed get isMobileMode() {\n\t\treturn this.userDocumentSettings.isMobileMode\n\t}\n\n\tprivate _isChangingStyle = atom<boolean>('isChangingStyle', false as any)\n\n\tprivate _isChangingStyleTimeout = -1 as any\n\n\t/**\n\t * Whether the user is currently changing the style of a shape. This may cause the UI to change.\n\t *\n\t * @public\n\t */\n\tget isChangingStyle() {\n\t\treturn this._isChangingStyle.value\n\t}\n\n\tset isChangingStyle(v) {\n\t\tthis._isChangingStyle.set(v)\n\t\t// Clear any reset timeout\n\t\tclearTimeout(this._isChangingStyleTimeout)\n\t\tif (v) {\n\t\t\t// If we've set to true, set a new reset timeout to change the value back to false after 2 seonds\n\t\t\tthis._isChangingStyleTimeout = setTimeout(() => (this.isChangingStyle = false), 2000)\n\t\t}\n\t}\n\n\treadonly store: TLStore\n\treadonly config: TldrawEditorConfig\n\n\t/**\n\t * The root state of the statechart.\n\t *\n\t * @public\n\t */\n\treadonly root: RootState\n\n\t/**\n\t * A cache of shape ids in the current page.\n\t *\n\t * @internal\n\t */\n\tprivate readonly _shapeIds: ReturnType<typeof shapeIdsInCurrentPage>\n\n\t/**\n\t * A cache of page transforms.\n\t *\n\t * @internal\n\t */\n\t@computed private get _pageTransformCache(): ComputedCache<Matrix2d, TLShape> {\n\t\treturn this.store.createComputedCache<Matrix2d, TLShape>('pageTransformCache', (shape) => {\n\t\t\tif (TLPage.isId(shape.parentId)) {\n\t\t\t\treturn this.getTransform(shape)\n\t\t\t}\n\t\t\t// some weird circular type thing here that I had to work wround with (as any)\n\t\t\tconst parent = (this._pageTransformCache as any).get(shape.parentId)\n\n\t\t\treturn Matrix2d.Compose(parent, this.getTransform(shape))\n\t\t})\n\t}\n\n\t/**\n\t * A cache of axis aligned page bounding boxes.\n\t *\n\t * @internal\n\t */\n\t@computed private get _pageBoundsCache(): ComputedCache<Box2d, TLShape> {\n\t\treturn this.store.createComputedCache<Box2d, TLShape>('pageBoundsCache', (shape) => {\n\t\t\tconst pageTransform = this._pageTransformCache.get(shape.id)\n\n\t\t\tif (!pageTransform) return new Box2d()\n\n\t\t\tconst result = Box2d.FromPoints(\n\t\t\t\tMatrix2d.applyToPoints(pageTransform, this.getShapeUtil(shape).outline(shape))\n\t\t\t)\n\n\t\t\treturn result\n\t\t})\n\t}\n\n\t@computed get _pageMaskCache(): ComputedCache<VecLike[], TLShape> {\n\t\treturn this.store.createComputedCache<VecLike[], TLShape>('pageMaskCache', (shape) => {\n\t\t\tif (TLPage.isId(shape.parentId)) {\n\t\t\t\treturn undefined\n\t\t\t}\n\n\t\t\tconst frameAncestors = this.getAncestorsById(shape.id).filter((s) => s.type === 'frame')\n\n\t\t\tif (frameAncestors.length === 0) return undefined\n\n\t\t\tconst pageMask = frameAncestors\n\t\t\t\t.map<VecLike[] | undefined>((s) =>\n\t\t\t\t\t// Apply the frame transform to the frame outline to get the frame outline in page space\n\t\t\t\t\tMatrix2d.applyToPoints(this._pageTransformCache.get(s.id)!, this.getOutline(s))\n\t\t\t\t)\n\t\t\t\t.reduce((acc, b) => (b && acc ? intersectPolygonPolygon(acc, b) ?? undefined : undefined))\n\n\t\t\treturn pageMask\n\t\t})\n\t}\n\n\t@computed get _clipPathCache(): ComputedCache<string, TLShape> {\n\t\treturn this.store.createComputedCache<string, TLShape>('clipPathCache', (shape) => {\n\t\t\tconst pageMask = this._pageMaskCache.get(shape.id)\n\t\t\tif (!pageMask) return undefined\n\t\t\tconst pageTransform = this._pageTransformCache.get(shape.id)\n\t\t\tif (!pageTransform) return undefined\n\n\t\t\tif (pageMask.length === 0) {\n\t\t\t\treturn `polygon(0px 0px, 0px 0px, 0px 0px)`\n\t\t\t}\n\n\t\t\tconst localMask = Matrix2d.applyToPoints(Matrix2d.Inverse(pageTransform), pageMask)\n\n\t\t\treturn `polygon(${localMask.map((p) => `${p.x}px ${p.y}px`).join(',')})`\n\t\t})\n\t}\n\n\t/**\n\t * A cache of parents to children.\n\t *\n\t * @internal\n\t */\n\tprivate readonly _parentsToChildrenWithIndexes: ReturnType<typeof parentsToChildrenWithIndexes>\n\n\t/**\n\t * Dispose the app.\n\t *\n\t * @public\n\t */\n\tdispose() {\n\t\tthis.disposables.forEach((dispose) => dispose())\n\t\tthis.disposables.clear()\n\t}\n\n\t/**\n\t * A manager for the app's history.\n\t *\n\t * @readonly\n\t */\n\thistory = new HistoryManager(\n\t\tthis,\n\t\t() => this._complete(),\n\t\t(error) => {\n\t\t\tthis.annotateError(error, { origin: 'history.batch', willCrashApp: true })\n\t\t\tthis.crash(error)\n\t\t}\n\t)\n\n\treadonly snaps = new SnapManager(this)\n\n\t/**\n\t * Undo to the last mark.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.undo()\n\t * ```\n\t *\n\t * @public\n\t */\n\tundo = () => this.history.undo()\n\n\t/**\n\t * Whether the app can undo.\n\t *\n\t * @public\n\t */\n\tget canUndo() {\n\t\treturn this.history.numUndos > 0\n\t}\n\n\t/**\n\t * Redo to the next mark.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.redo()\n\t * ```\n\t *\n\t * @public\n\t */\n\tredo = () => this.history.redo()\n\n\t/**\n\t * Whether the app can redo.\n\t *\n\t * @public\n\t */\n\tget canRedo() {\n\t\treturn this.history.numRedos > 0\n\t}\n\n\t/**\n\t * Create a new \"mark\", or stopping point, in the undo redo history. Creating a mark will clear\n\t * any redos.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.mark()\n\t * \tapp.mark('flip shapes')\n\t * ```\n\t *\n\t * @param reason - The reason for the mark.\n\t * @param onUndo - Whether to stop at the mark when undoing.\n\t * @param onRedo - Whether to stop at the mark when redoing.\n\t * @public\n\t */\n\tmark = (reason?: string, onUndo?: boolean, onRedo?: boolean) => {\n\t\treturn this.history.mark(reason, onUndo, onRedo)\n\t}\n\n\tbail = () => this.history.bail()\n\n\tbailToMark = (id: string) => this.history.bailToMark(id)\n\n\tbatch = (fn: () => void) => this.history.batch(fn)\n\n\t/**\n\t * A map of shape utility classes (TLShapeUtils) by shape type.\n\t *\n\t * @internal\n\t */\n\tprivate shapeUtils: { readonly [K in string]?: TLShapeUtil<TLUnknownShape> }\n\tgetShapeUtilByDef<Def extends TLShapeDef<any, any>>(\n\t\tdef: Def\n\t): ReturnType<Def['createShapeUtils']> {\n\t\treturn this.shapeUtils[def.type] as ReturnType<Def['createShapeUtils']>\n\t}\n\n\t/**\n\t * A cache of children for each parent.\n\t *\n\t * @internal\n\t */\n\tprivate _childrenCache = new WeakMapCache<any[], TLShapeId[]>()\n\n\t/**\n\t * Get an array of all the children of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getChildren('frame1')\n\t * ```\n\t *\n\t * @param parentId - The id of the parent shape.\n\t * @public\n\t */\n\tgetSortedChildren(parentId: TLParentId): TLShapeId[] {\n\t\tconst withIndices = this._parentsToChildrenWithIndexes.value[parentId]\n\t\tif (!withIndices) return EMPTY_ARRAY\n\t\treturn this._childrenCache.get(withIndices, () => withIndices.map(([id]) => id))\n\t}\n\n\t/**\n\t * Run a visitor function for all descendants of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.visitDescendants('frame1', myCallback)\n\t * ```\n\t *\n\t * @param parentId - The id of the parent shape.\n\t * @param visitor - The visitor function.\n\t * @public\n\t */\n\tvisitDescendants(parentId: TLParentId, visitor: (id: TLShapeId) => void | false) {\n\t\tconst children = this.getSortedChildren(parentId)\n\t\tfor (const id of children) {\n\t\t\tif (visitor(id) === false) continue\n\t\t\tthis.visitDescendants(id, visitor)\n\t\t}\n\t}\n\n\t@computed get erasingIds() {\n\t\treturn this.pageState.erasingIds\n\t}\n\n\t@computed get hintingIds() {\n\t\treturn this.pageState.hintingIds\n\t}\n\n\t/**\n\t * A derived set containing the current erasing ids.\n\t *\n\t * @public\n\t */\n\t@computed get erasingIdsSet() {\n\t\t// todo: Make incremental derivation, so that this only gets updated when erasingIds changes: we're creating this too often!\n\t\treturn new Set<TLShapeId>(this.erasingIds)\n\t}\n\n\t/** Get all the current props among the users selected shapes */\n\tprivate _extractSharedProps = (shape: TLShape, sharedProps: TLNullableShapeProps) => {\n\t\tif (shape.type === 'group') {\n\t\t\t// For groups, ignore the props of the group shape and instead include\n\t\t\t// the props of the group's children. These are the shapes that would have\n\t\t\t// their props changed if the user called `setProp` on the current selection.\n\t\t\tconst childIds = this._parentsToChildrenWithIndexes.value[shape.id]\n\n\t\t\tfor (let i = 0, n = childIds.length; i < n; i++) {\n\t\t\t\tthis._extractSharedProps(this.getShapeById(childIds[i][0])!, sharedProps)\n\t\t\t}\n\t\t} else {\n\t\t\tconst props = Object.entries(shape.props)\n\t\t\tlet prop: [TLShapeProp, any]\n\t\t\tfor (let i = 0, n = props.length; i < n; i++) {\n\t\t\t\tprop = props[i] as [TLShapeProp, any]\n\n\t\t\t\t// Check the value of this prop on the shared props object.\n\t\t\t\tswitch (sharedProps[prop[0]]) {\n\t\t\t\t\tcase undefined: {\n\t\t\t\t\t\t// If this key hasn't been defined yet in the shared props object,\n\t\t\t\t\t\t// we can set it to the value from the shape's props object.\n\t\t\t\t\t\tsharedProps[prop[0]] = prop[1]\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase null:\n\t\t\t\t\tcase prop[1]: {\n\t\t\t\t\t\t// If the value in the shared props object matches the value from\n\t\t\t\t\t\t// the shape's props object exactly\u2014or if there is already a mixed\n\t\t\t\t\t\t// value (null) in the shared props object\u2014then this is a noop. We\n\t\t\t\t\t\t// want to leave the value as it is in the shared props object.\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\t// If there's a value in the shared props object that isn't null AND\n\t\t\t\t\t\t// that isn't undefined AND that doesn't match the shape's props object,\n\t\t\t\t\t\t// then we've got a conflict, mixed props, so set the value to null.\n\t\t\t\t\t\tsharedProps[prop[0]] = null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A derived object containing all current props among the user's selected shapes.\n\t *\n\t * @internal\n\t */\n\tprivate _selectionSharedProps = computed<TLNullableShapeProps>('_selectionSharedProps', () => {\n\t\tconst { selectedShapes } = this\n\n\t\tconst sharedProps = {} as TLNullableShapeProps\n\n\t\tfor (let i = 0, n = selectedShapes.length; i < n; i++) {\n\t\t\tthis._extractSharedProps(selectedShapes[i], sharedProps)\n\t\t}\n\n\t\treturn sharedProps as TLNullableShapeProps\n\t})\n\n\t@computed get allowUiPaste() {\n\t\treturn Boolean(navigator.clipboard) && Boolean(navigator.clipboard.read)\n\t}\n\n\tprivate _prevProps: any = {}\n\n\t/**\n\t * A derived object containing either all current props among the user's selected shapes, or else\n\t * the user's most recent prop choices that correspond to the current active state (i.e. the\n\t * selected tool).\n\t *\n\t * @internal\n\t */\n\t@computed get props(): TLNullableShapeProps | null {\n\t\tlet next: TLNullableShapeProps | null\n\n\t\t// If we're in selecting and if we have a selection,\n\t\t// return the shared props from the current selection\n\t\tif (this.isIn('select') && this.selectedIds.length > 0) {\n\t\t\tnext = this._selectionSharedProps.value\n\t\t} else {\n\t\t\t// Otherwise, pull the style props from the app state\n\t\t\t// (the most recent choices made by the user) that are\n\t\t\t// exposed by the current state (i.e. the active tool).\n\t\t\tconst currentState = this.root.current.value!\n\t\t\tif (currentState.styles.length === 0) {\n\t\t\t\tnext = null\n\t\t\t} else {\n\t\t\t\tconst { propsForNextShape } = this.instanceState\n\t\t\t\tnext = Object.fromEntries(\n\t\t\t\t\tcurrentState.styles.map((k) => {\n\t\t\t\t\t\treturn [k, propsForNextShape[k]]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\t// todo: any way to improve this? still faster than rendering the style panel every frame\n\t\tif (JSON.stringify(this._prevProps) === JSON.stringify(next)) return this._prevProps\n\n\t\tthis._prevProps = next\n\n\t\treturn next\n\t}\n\n\t/**\n\t * An array of all of the shapes on the current page.\n\t *\n\t * @public\n\t */\n\tget shapeIds() {\n\t\treturn this._shapeIds.value\n\t}\n\n\t/**\n\t * _invalidParents is used to trigger the 'onChildrenChange' callback that shapes\n\t * can have.\n\t */\n\tprivate readonly _invalidParents = new Set<TLShapeId>()\n\n\t// Commands\n\t_complete = () => {\n\t\tconst { lastUpdatedPageId, lastUsedTabId } = this.userDocumentSettings\n\t\tif (lastUsedTabId !== this.instanceId || lastUpdatedPageId !== this.currentPageId) {\n\t\t\tthis.store.put([\n\t\t\t\t{\n\t\t\t\t\t...this.userDocumentSettings,\n\t\t\t\t\tlastUsedTabId: this.instanceId,\n\t\t\t\t\tlastUpdatedPageId: this.currentPageId,\n\t\t\t\t},\n\t\t\t])\n\t\t}\n\t\tfor (const parentId of this._invalidParents) {\n\t\t\tthis._invalidParents.delete(parentId)\n\t\t\tconst parent = this.getShapeById(parentId)\n\t\t\tif (!parent) continue\n\n\t\t\tconst util = this.getShapeUtil(parent)\n\t\t\tconst changes = util.onChildrenChange?.(parent)\n\n\t\t\tif (changes?.length) {\n\t\t\t\tthis._updateShapes(changes, true)\n\t\t\t}\n\t\t}\n\n\t\tthis.updateUserPresence()\n\t\tthis.emit('update')\n\t}\n\n\t@computed\n\tprivate get _arrowBindingsIndex() {\n\t\treturn arrowBindingsIndex(this.store)\n\t}\n\n\t/**\n\t * getArrowsBoundTo\n\t */\n\tgetArrowsBoundTo(shapeId: TLShapeId) {\n\t\treturn this._arrowBindingsIndex.value[shapeId] || EMPTY_ARRAY\n\t}\n\n\tprivate _reparentArrow = (arrowId: TLShapeId) => {\n\t\tconst arrow = this.getShapeById(arrowId) as TLArrowShape | undefined\n\t\tif (!arrow) return\n\t\tconst { start, end } = arrow.props\n\t\tconst startShape = start.type === 'binding' ? this.getShapeById(start.boundShapeId) : undefined\n\t\tconst endShape = end.type === 'binding' ? this.getShapeById(end.boundShapeId) : undefined\n\n\t\tconst parentPageId = this.getParentPageId(arrow)\n\t\tif (!parentPageId) return\n\n\t\tlet nextParentId: TLParentId\n\t\tif (startShape && endShape) {\n\t\t\t// if arrow has two bindings, always parent arrow to closest common ancestor of the bindings\n\t\t\tnextParentId = this.findCommonAncestor([startShape, endShape]) ?? parentPageId\n\t\t} else if (startShape || endShape) {\n\t\t\t// if arrow has one binding, keep arrow on its own page\n\t\t\tnextParentId = parentPageId\n\t\t} else {\n\t\t\treturn\n\t\t}\n\n\t\tif (nextParentId && nextParentId !== arrow.parentId) {\n\t\t\tthis.reparentShapes([arrowId], nextParentId)\n\t\t}\n\n\t\tconst reparentedArrow = this.getShapeById(arrowId) as TLArrowShape\n\n\t\tconst startSibling = this.getNearestSiblingShape(reparentedArrow, startShape)\n\t\tconst endSibling = this.getNearestSiblingShape(reparentedArrow, endShape)\n\n\t\tlet highestSibling: TLShape | undefined\n\n\t\tif (startSibling && endSibling) {\n\t\t\thighestSibling = startSibling.index > endSibling.index ? startSibling : endSibling\n\t\t} else if (startSibling && !endSibling) {\n\t\t\thighestSibling = startSibling\n\t\t} else if (endSibling && !startSibling) {\n\t\t\thighestSibling = endSibling\n\t\t} else {\n\t\t\treturn\n\t\t}\n\n\t\tlet finalIndex: string\n\n\t\tconst higherSiblings = this.getSortedChildren(highestSibling.parentId)\n\t\t\t.map((id) => this.getShapeById(id)!)\n\t\t\t.filter((sibling) => sibling.index > highestSibling!.index)\n\n\t\tif (higherSiblings.length) {\n\t\t\t// there are siblings above the highest bound sibling, we need to\n\t\t\t// insert between them.\n\n\t\t\t// if the next sibling is also a bound arrow though, we can end up\n\t\t\t// all fighting for the same indexes. so lets find the next\n\t\t\t// non-arrow sibling...\n\t\t\tconst nextHighestNonArrowSibling = higherSiblings.find((sibling) => sibling.type !== 'arrow')\n\n\t\t\tif (\n\t\t\t\t// ...then, if we're above the last shape we want to be above...\n\t\t\t\treparentedArrow.index > highestSibling.index &&\n\t\t\t\t// ...but below the next non-arrow sibling...\n\t\t\t\t(!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)\n\t\t\t) {\n\t\t\t\t// ...then we're already in the right place. no need to update!\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// otherwise, we need to find the index between the highest sibling\n\t\t\t// we want to be above, and the next highest sibling we want to be\n\t\t\t// below:\n\t\t\tfinalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index)\n\t\t} else {\n\t\t\t// if there are no siblings above us, we can just get the next index:\n\t\t\tfinalIndex = getIndexAbove(highestSibling.index)\n\t\t}\n\n\t\tif (finalIndex !== reparentedArrow.index) {\n\t\t\tthis.updateShapes([{ id: arrowId, type: 'arrow', index: finalIndex }])\n\t\t}\n\t}\n\n\tprivate _unbindArrowTerminal = (arrow: TLArrowShape, handleId: 'start' | 'end') => {\n\t\tconst { x, y } = getArrowTerminalsInArrowSpace(this, arrow)[handleId]\n\t\tthis.store.put([{ ...arrow, props: { ...arrow.props, [handleId]: { type: 'point', x, y } } }])\n\t}\n\n\t// private _shapeWillUpdate = (prev: TLShape, next: TLShape) => {\n\t// \tconst update = this.getShapeUtil(next).onUpdate?.(prev, next)\n\t// \treturn update ?? next\n\t// }\n\n\tprivate _shapeWillBeDeleted = (deletedShape: TLShape) => {\n\t\t// if the deleted shape has a parent shape make sure we call it's onChildrenChange callback\n\t\tif (deletedShape.parentId && isShapeId(deletedShape.parentId)) {\n\t\t\tthis._invalidParents.add(deletedShape.parentId)\n\t\t}\n\t\t// clean up any arrows bound to this shape\n\t\tconst bindings = this._arrowBindingsIndex.value[deletedShape.id]\n\t\tif (bindings?.length) {\n\t\t\tfor (const { arrowId, handleId } of bindings) {\n\t\t\t\tconst arrow = this.getShapeById<TLArrowShape>(arrowId)\n\t\t\t\tif (!arrow) continue\n\t\t\t\tthis._unbindArrowTerminal(arrow, handleId)\n\t\t\t}\n\t\t}\n\n\t\tconst pageStates = this.store.query.records('instance_page_state').value\n\t\tconst deletedIds = new Set([deletedShape.id])\n\t\tconst updates = compact(\n\t\t\tpageStates.map((pageState) => {\n\t\t\t\treturn this._cleanupInstancePageState(pageState, deletedIds)\n\t\t\t})\n\t\t)\n\n\t\tif (updates.length) {\n\t\t\tthis.store.put(updates)\n\t\t}\n\t}\n\n\tprivate _arrowDidUpdate = (arrow: TLArrowShape) => {\n\t\t// if the shape is an arrow and its bound shape is on another page\n\t\t// or was deleted, unbind it\n\t\tfor (const handle of ['start', 'end'] as const) {\n\t\t\tconst terminal = arrow.props[handle]\n\t\t\tif (terminal.type !== 'binding') continue\n\t\t\tconst boundShape = this.getShapeById(terminal.boundShapeId)\n\t\t\tconst isShapeInSamePageAsArrow =\n\t\t\t\tthis.getParentPageId(arrow) === this.getParentPageId(boundShape)\n\t\t\tif (!boundShape || !isShapeInSamePageAsArrow) {\n\t\t\t\tthis._unbindArrowTerminal(arrow, handle)\n\t\t\t}\n\t\t}\n\n\t\t// always check the arrow parents\n\t\tthis._reparentArrow(arrow.id)\n\t}\n\n\tprivate _cleanupInstancePageState = (\n\t\tprevPageState: TLInstancePageState,\n\t\tshapesNoLongerInPage: Set<TLShapeId>\n\t) => {\n\t\tlet nextPageState = null as null | TLInstancePageState\n\n\t\tconst selectedIds = prevPageState.selectedIds.filter((id) => !shapesNoLongerInPage.has(id))\n\t\tif (selectedIds.length !== prevPageState.selectedIds.length) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.selectedIds = selectedIds\n\t\t}\n\n\t\tconst erasingIds = prevPageState.erasingIds.filter((id) => !shapesNoLongerInPage.has(id))\n\t\tif (erasingIds.length !== prevPageState.erasingIds.length) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.erasingIds = erasingIds\n\t\t}\n\n\t\tif (prevPageState.hoveredId && shapesNoLongerInPage.has(prevPageState.hoveredId)) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.hoveredId = null\n\t\t}\n\n\t\tif (prevPageState.editingId && shapesNoLongerInPage.has(prevPageState.editingId)) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.editingId = null\n\t\t}\n\n\t\tconst hintingIds = prevPageState.hintingIds.filter((id) => !shapesNoLongerInPage.has(id))\n\t\tif (hintingIds.length !== prevPageState.hintingIds.length) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.hintingIds = hintingIds\n\t\t}\n\n\t\tif (prevPageState.focusLayerId && shapesNoLongerInPage.has(prevPageState.focusLayerId)) {\n\t\t\tif (!nextPageState) nextPageState = { ...prevPageState }\n\t\t\tnextPageState.focusLayerId = null\n\t\t}\n\t\treturn nextPageState\n\t}\n\n\tprivate _shapeDidChange = (prev: TLShape, next: TLShape) => {\n\t\tif (TLArrowShapeDef.is(next)) {\n\t\t\tthis._arrowDidUpdate(next)\n\t\t}\n\n\t\t// if the shape's parent changed and it is bound to an arrow, update the arrow's parent\n\t\tif (prev.parentId !== next.parentId) {\n\t\t\tconst reparentBoundArrows = (id: TLShapeId) => {\n\t\t\t\tconst boundArrows = this._arrowBindingsIndex.value[id]\n\t\t\t\tif (boundArrows?.length) {\n\t\t\t\t\tfor (const arrow of boundArrows) {\n\t\t\t\t\t\tthis._reparentArrow(arrow.arrowId)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treparentBoundArrows(next.id)\n\t\t\tthis.visitDescendants(next.id, reparentBoundArrows)\n\t\t}\n\n\t\t// if this shape moved to a new page, clean up any previous page's instance state\n\t\tif (prev.parentId !== next.parentId && TLPage.isId(next.parentId)) {\n\t\t\tconst allMovingIds = new Set([prev.id])\n\t\t\tthis.visitDescendants(prev.id, (id) => {\n\t\t\t\tallMovingIds.add(id)\n\t\t\t})\n\n\t\t\tfor (const instancePageState of this.store.query.records('instance_page_state').value) {\n\t\t\t\tif (instancePageState.pageId === next.parentId) continue\n\t\t\t\tconst nextPageState = this._cleanupInstancePageState(instancePageState, allMovingIds)\n\n\t\t\t\tif (nextPageState) {\n\t\t\t\t\tthis.store.put([nextPageState])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (prev.parentId && isShapeId(prev.parentId)) {\n\t\t\tthis._invalidParents.add(prev.parentId)\n\t\t}\n\n\t\tif (next.parentId !== prev.parentId && isShapeId(next.parentId)) {\n\t\t\tthis._invalidParents.add(next.parentId)\n\t\t}\n\t}\n\n\tprivate _tabStateDidChange = (prev: TLInstancePageState, next: TLInstancePageState) => {\n\t\tif (prev?.selectedIds !== next?.selectedIds) {\n\t\t\t// ensure that descendants and ascenants are not selected at the same time\n\t\t\tconst filtered = next.selectedIds.filter((id) => {\n\t\t\t\tlet parentId = this.getShapeById(id)?.parentId\n\t\t\t\twhile (isShapeId(parentId)) {\n\t\t\t\t\tif (next.selectedIds.includes(parentId)) {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\tparentId = this.getShapeById(parentId)?.parentId\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t})\n\n\t\t\tconst nextFocusLayerId =\n\t\t\t\tfiltered.length === 0\n\t\t\t\t\t? next?.focusLayerId\n\t\t\t\t\t: this.findCommonAncestor(\n\t\t\t\t\t\t\tcompact(filtered.map(this.getShapeById)),\n\t\t\t\t\t\t\t(shape) => shape.type === 'group'\n\t\t\t\t\t  )\n\n\t\t\tif (filtered.length !== next.selectedIds.length || nextFocusLayerId != next.focusLayerId) {\n\t\t\t\tthis.store.put([{ ...next, selectedIds: filtered, focusLayerId: nextFocusLayerId ?? null }])\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _pageWillBeDeleted = (page: TLPage) => {\n\t\t// page was deleted, need to check whether it's the current page and select another one if so\n\t\tconst instanceStates = this.store.query.exec('instance', { currentPageId: { eq: page.id } })\n\n\t\tif (!instanceStates.length) return\n\t\tconst backupPageId = this.pages.find((p) => p.id !== page.id)?.id\n\n\t\tif (!backupPageId) return\n\n\t\tthis.store.put(instanceStates.map((state) => ({ ...state, currentPageId: backupPageId })))\n\t}\n\n\t/* -------------------- Shortcuts ------------------- */\n\n\t/** The global document settings that applies to all users */\n\t@computed get documentSettings() {\n\t\treturn this.store.get(TLDOCUMENT_ID)!\n\t}\n\n\tget gridSize() {\n\t\treturn this.documentSettings.gridSize\n\t}\n\n\t/**\n\t * The user's global settings.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\tget userSettings(): TLUser {\n\t\treturn this.store.get(this.userId)!\n\t}\n\n\t@computed private get _userDocumentSettings() {\n\t\treturn this.store.query.record('user_document', () => ({ userId: { eq: this.userId } }))\n\t}\n\n\tget userDocumentSettings(): TLUserDocument {\n\t\treturn this._userDocumentSettings.value!\n\t}\n\n\tget isReadOnly() {\n\t\treturn this.userDocumentSettings.isReadOnly\n\t}\n\n\tget isGridMode() {\n\t\treturn this.userDocumentSettings.isGridMode\n\t}\n\n\tsetGridMode(isGridMode: boolean) {\n\t\tthis.updateUserDocumentSettings({ isGridMode }, true)\n\t}\n\n\tsetDarkMode(isDarkMode: boolean) {\n\t\tthis.updateUserDocumentSettings({ isDarkMode }, true)\n\t}\n\n\t_isPenMode = atom<boolean>('isPenMode', false as any)\n\t_touchEventsRemainingBeforeExitingPenMode = 0\n\n\tget isPenMode() {\n\t\treturn this._isPenMode.value\n\t}\n\n\tsetPenMode(isPenMode: boolean) {\n\t\tif (isPenMode) this._touchEventsRemainingBeforeExitingPenMode = 3\n\n\t\tthis._isPenMode.set(isPenMode)\n\t}\n\n\t// User / User App State\n\n\t/**\n\t * The current user state.\n\t *\n\t * @public\n\t */\n\tget user(): TLUser {\n\t\treturn this.store.get(this.userId)!\n\t}\n\n\t/** The current tab state */\n\tget instanceState(): TLInstance {\n\t\treturn this.store.get(this.instanceId)!\n\t}\n\n\tget cursor() {\n\t\treturn this.instanceState.cursor\n\t}\n\n\tget brush() {\n\t\treturn this.instanceState.brush\n\t}\n\n\tget scribble() {\n\t\treturn this.instanceState.scribble\n\t}\n\n\t@computed private get _pageState() {\n\t\treturn this.store.query.record(\n\t\t\t'instance_page_state',\n\t\t\t() => {\n\t\t\t\treturn {\n\t\t\t\t\tpageId: { eq: this.currentPageId },\n\t\t\t\t\tinstanceId: { eq: this.instanceId },\n\t\t\t\t}\n\t\t\t},\n\t\t\t'app._pageState'\n\t\t)\n\t}\n\n\t/**\n\t * The current page state.\n\t *\n\t * @public\n\t */\n\tget pageState(): TLInstancePageState {\n\t\treturn this._pageState.value!\n\t}\n\n\t/**\n\t * The current camera.\n\t */\n\t@computed get camera() {\n\t\treturn this.store.get(this.pageState.cameraId)!\n\t}\n\n\t/**\n\t * The current camera zoom level.\n\t */\n\t@computed get zoomLevel() {\n\t\treturn this.camera.z\n\t}\n\n\t/**\n\t * The current selected ids.\n\t *\n\t * @public\n\t */\n\t@computed get selectedIds() {\n\t\treturn this.pageState.selectedIds\n\t}\n\n\t/**\n\t * The current selected ids as a set\n\t * @public\n\t */\n\t@computed get selectedIdsSet(): ReadonlySet<TLShapeId> {\n\t\treturn new Set(this.selectedIds)\n\t}\n\n\t// Pages\n\n\t@computed private get _pages() {\n\t\treturn this.store.query.records('page')\n\t}\n\n\t/**\n\t * Info about the project's current pages.\n\t *\n\t * @public\n\t * @readonly\n\t */\n\t@computed get pages() {\n\t\treturn this._pages.value.sort(sortByIndex)\n\t}\n\n\t/**\n\t * The current page.\n\t *\n\t * @public\n\t */\n\tget currentPage() {\n\t\treturn this.getPageById(this.currentPageId)!\n\t}\n\n\t/**\n\t * The current page id.\n\t *\n\t * @public\n\t */\n\tget currentPageId() {\n\t\treturn this.instanceState.currentPageId\n\t}\n\n\t/**\n\t * Get a page by its ID.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPageById(myPage.id)\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetPageById(id: TLPage['id']) {\n\t\treturn this.store.get(id)\n\t}\n\n\t@computed private get _pageStates() {\n\t\treturn this.store.query.records('instance_page_state', () => ({\n\t\t\tinstanceId: { eq: this.instanceId },\n\t\t}))\n\t}\n\n\t/**\n\t * Get a page state by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPageStateByPageId('page1')\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetPageStateByPageId = (id: TLPageId) => {\n\t\treturn this._pageStates.value.find((p) => p.pageId === id)\n\t}\n\n\t/**\n\t * Get a page by its ID.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPageById(myPage.id)\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetPageInfoById(id: TLPage['id']) {\n\t\treturn this.store.get(id)\n\t}\n\n\t/**\n\t * Get shapes on a page.\n\t */\n\tgetShapesInPage(pageId: TLPageId) {\n\t\tconst result = this.store.query.exec('shape', { parentId: { eq: pageId } })\n\t\treturn this.getShapesAndDescendantsInOrder(result.map((s) => s.id))\n\t}\n\n\t/* ------------------- ShapeUtils ------------------- */\n\n\t/**\n\t * Get a shape util for a given shape or shape type.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getShapeUtil('geo')\n\t * ```\n\t * \tapp.getShapeUtil(myBoxShape)\n\t *\n\t * @param type - The shape type.\n\t */\n\tgetShapeUtil = <T extends TLShape = TLShape>(shape: T): TLShapeUtil<T> => {\n\t\treturn this.shapeUtils[shape.type] as any as TLShapeUtil<T>\n\t}\n\n\t/* --------------------- Shapes --------------------- */\n\n\t/**\n\t * Get the local transform for a shape as a matrix model. This transform reflects both its\n\t * translation (x, y) from from either its parent's top left corner, if the shape's parent is\n\t * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the\n\t * shape's rotation.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the local transform for.\n\t * @public\n\t */\n\tgetTransform = (shape: TLShape) => {\n\t\tconst util = this.getShapeUtil(shape)\n\t\treturn util.transform(shape)\n\t}\n\n\t/**\n\t * Get the local transform of a shape's parent as a matrix model.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getParentTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the parent transform for.\n\t * @public\n\t */\n\tgetParentTransform = (shape: TLShape) => {\n\t\tif (TLPage.isId(shape.parentId)) {\n\t\t\treturn Matrix2d.Identity()\n\t\t}\n\t\treturn this._pageTransformCache.get(shape.parentId) ?? Matrix2d.Identity()\n\t}\n\n\t/**\n\t * Get the page transform (or absolute transform) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPageTransform(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page transform for.\n\t * @public\n\t */\n\tgetPageTransform = (shape: TLShape) => {\n\t\treturn this.getPageTransformById(shape.id)\n\t}\n\n\t/**\n\t * Get the page transform (or absolute transform) of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPageTransformById(myShape)\n\t * ```\n\t *\n\t * @param id - The if of the shape to get the page transform for.\n\t * @public\n\t */\n\tgetPageTransformById = (id: TLShapeId) => {\n\t\treturn this._pageTransformCache.get(id)\n\t}\n\n\t/**\n\t * Get the page point (or absolute point) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPagePoint(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page point for.\n\t * @public\n\t */\n\tgetPagePointById = (id: TLShapeId) => {\n\t\tconst pageTransform = this.getPageTransformById(id)\n\t\tif (!pageTransform) return\n\t\treturn Matrix2d.applyToPoint(pageTransform, new Vec2d())\n\t}\n\n\t/**\n\t * Get the page point (or absolute point) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPagePoint(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page point for.\n\t * @public\n\t */\n\tgetPageCenter = (shape: TLShape) => {\n\t\tconst pageTransform = this.getPageTransformById(shape.id)\n\t\tif (!pageTransform) return null\n\t\tconst util = this.getShapeUtil(shape)\n\t\tconst center = util.center(shape)\n\t\treturn Matrix2d.applyToPoint(pageTransform, center)\n\t}\n\n\t/**\n\t * Get the page point (or absolute point) of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPagePoint(myShape)\n\t * ```\n\t *\n\t * @param id - The shape id to get the page point for.\n\t * @public\n\t */\n\tgetPageCenterById = (id: TLShapeId) => {\n\t\tconst shape = this.getShapeById(id)!\n\t\treturn this.getPageCenter(shape)\n\t}\n\n\t/**\n\t * Get the page rotation (or absolute rotation) of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPageRotation(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the page rotation for.\n\t * @public\n\t */\n\tgetPageRotation = (shape: TLShape): number => {\n\t\treturn this.getPageRotationById(shape.id)\n\t}\n\n\t/**\n\t * Get the page rotation (or absolute rotation) of a shape by its id.\n\t *\n\t * @param id - The id of the shape to get the page rotation for.\n\t */\n\tgetPageRotationById = (id: TLShapeId): number => {\n\t\tconst pageTransform = this.getPageTransformById(id)\n\t\tif (pageTransform) {\n\t\t\treturn Matrix2d.Decompose(pageTransform).rotation\n\t\t}\n\t\treturn 0\n\t}\n\n\t/**\n\t * Get the local bounds of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getBounds(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the bounds for.\n\t * @public\n\t */\n\tgetBounds = (shape: TLShape): Box2d => {\n\t\treturn this.getShapeUtil(shape).bounds(shape)\n\t}\n\n\t/**\n\t * Get the local bounds of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getBoundsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the bounds for.\n\t * @public\n\t */\n\tgetBoundsById = (id: TLShapeId): Box2d | undefined => {\n\t\tconst shape = this.getShapeById(id)\n\t\tif (!shape) return undefined\n\t\treturn this.getBounds(shape)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPageBounds(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the bounds for.\n\t * @public\n\t */\n\tgetPageBounds = (shape: TLShape): Box2d | undefined => {\n\t\treturn this.getPageBoundsById(shape.id)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPageBoundsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the page bounds for.\n\t * @public\n\t */\n\tgetPageBoundsById = (id: TLShapeId): Box2d | undefined => {\n\t\treturn this._pageBoundsCache.get(id)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape, incorporating any masks.\n\t * For example, if the shape were the child of a frame and was half way out of the frame,\n\t * the bounds would be the half of the shape that was in the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getMaskedPageBounds(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the masked bounds for.\n\t * @public\n\t */\n\tgetMaskedPageBounds = (shape: TLShape): Box2d | undefined => {\n\t\treturn this.getMaskedPageBoundsById(shape.id)\n\t}\n\n\t/**\n\t * Get the page (or absolute) bounds of a shape by its id, incorporating any masks.\n\t * For example, if the shape were the child of a frame and was half way out of the frame,\n\t * the bounds would be the half of the shape that was in the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getMaskedPageBoundsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the masked page bounds for.\n\t * @public\n\t */\n\tgetMaskedPageBoundsById = (id: TLShapeId): Box2d | undefined => {\n\t\tconst pageBounds = this._pageBoundsCache.get(id)\n\t\tif (!pageBounds) return\n\t\tconst pageMask = this._pageMaskCache.get(id)\n\t\tif (pageMask) {\n\t\t\tconst intersection = intersectPolygonPolygon(pageMask, pageBounds.corners)\n\t\t\tif (!intersection) return\n\t\t\treturn Box2d.FromPoints(intersection)\n\t\t}\n\t\treturn pageBounds\n\t}\n\n\t/**\n\t * Get the local outline of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getOutline(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the outline for.\n\t * @public\n\t */\n\tgetOutline = (shape: TLShape) => {\n\t\treturn this.getShapeUtil(shape).outline(shape)\n\t}\n\n\t/**\n\t * Get the local outline of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getOutlineById(myShape)\n\t * ```\n\t *\n\t * @param id - The shape id to get the outline for.\n\t * @public\n\t */\n\tgetOutlineById = (id: TLShapeId) => {\n\t\treturn this.getOutline(this.getShapeById(id)!)\n\t}\n\n\t/**\n\t * Get the ancestors of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tconst ancestors = app.getAncestors(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the ancestors for.\n\t * @public\n\t */\n\tgetAncestors = (shape: TLShape, acc: TLShape[] = []): TLShape[] => {\n\t\tconst parentId = shape.parentId\n\t\tif (TLPage.isId(parentId)) {\n\t\t\tacc.reverse()\n\t\t\treturn acc\n\t\t}\n\n\t\tconst parent = this.store.get(parentId)!\n\t\tacc.push(parent)\n\t\treturn this.getAncestors(parent, acc)\n\t}\n\n\t/**\n\t * Get the ancestors of a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * \tconst ancestors = app.getAncestorsById(myShape)\n\t * ```\n\t *\n\t * @param id - The id of the shape to get the ancestors for.\n\t * @public\n\t */\n\tgetAncestorsById = (id: TLShapeId, acc: TLShape[] = []): TLShape[] => {\n\t\tconst shape = this.getShapeById(id)!\n\t\treturn this.getAncestors(shape, acc)\n\t}\n\n\t/**\n\t * Find the first ancestor matching the given predicate\n\t *\n\t * @example\n\t * ```ts\n\t * \tconst ancestor = app.findAncestor(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to check the ancestors for.\n\t * @public\n\t */\n\tfindAncestor = (shape: TLShape, predicate: (parent: TLShape) => boolean): TLShape | undefined => {\n\t\tconst parentId = shape.parentId\n\n\t\tif (TLPage.isId(parentId)) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tconst parent = this.getShapeById(parentId)\n\n\t\tif (parent) {\n\t\t\tif (predicate(parent)) {\n\t\t\t\treturn parent\n\t\t\t}\n\t\t\treturn this.findAncestor(parent, predicate)\n\t\t}\n\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Returns true if the the given shape has the given ancestor\n\t *\n\t */\n\thasAncestor(shape: TLShape | undefined, ancestorId: TLShapeId): boolean {\n\t\tif (!shape) return false\n\t\tif (shape.parentId === ancestorId) return true\n\t\treturn this.hasAncestor(this.getParentShape(shape), ancestorId)\n\t}\n\n\t/**\n\t * Get the common ancestor of two or more shapes that matches a predicate.\n\t *\n\t * @param shapes - The shapes to check.\n\t * @param predicate - The predicate to match.\n\t */\n\tfindCommonAncestor(\n\t\tshapes: TLShape[],\n\t\tpredicate?: (shape: TLShape) => boolean\n\t): TLShapeId | undefined {\n\t\tif (shapes.length === 0) {\n\t\t\treturn\n\t\t}\n\t\tif (shapes.length === 1) {\n\t\t\tconst parentId = shapes[0].parentId\n\t\t\tif (TLPage.isId(parentId)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn predicate ? this.findAncestor(shapes[0], predicate)?.id : parentId\n\t\t}\n\n\t\tconst [nodeA, ...others] = shapes\n\t\tlet ancestor = this.getParentShape(nodeA)\n\t\twhile (ancestor) {\n\t\t\t// TODO: this is not ideal, optimize\n\t\t\tif (predicate && !predicate(ancestor)) {\n\t\t\t\tancestor = this.getParentShape(ancestor)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (others.every((shape) => this.hasAncestor(shape, ancestor!.id))) {\n\t\t\t\treturn ancestor!.id\n\t\t\t}\n\t\t\tancestor = this.getParentShape(ancestor)\n\t\t}\n\t\treturn undefined\n\t}\n\n\t/**\n\t * Check whether a shape is within the bounds of the current viewport.\n\t *\n\t * @param id - The id of the shape to check.\n\t *\n\t * @public\n\t */\n\tisShapeInViewport = (id: TLShapeId) => {\n\t\tconst pageBounds = this.getPageBoundsById(id)\n\t\tif (!pageBounds) return false\n\t\treturn this.viewport.includes(pageBounds)\n\t}\n\n\t/**\n\t * Get the shapes that should be displayed in the current viewport.\n\t *\n\t * @public\n\t */\n\t@computed get renderingShapes() {\n\t\t// Here we get the shape as well as any of its children, as well as their\n\t\t// opacities. If the shape is beign erased, and none of its ancestors are\n\t\t// being erased, then we reduce the opacity of the shape and all of its\n\t\t// ancestors; but we don't apply this effect more than once among a set\n\t\t// of descendants so that it does not compound.\n\n\t\t// This is designed to keep all the shapes in a single list which\n\t\t// allows the DOM nodes to be reused even when they become children\n\t\t// of other nodes.\n\n\t\t// Its IMPORTANT that the result be sorted by id AND include the index\n\t\t// that the shape should be displayed at. Steve, this is the past you\n\t\t// telling the present you not to change this.\n\n\t\t// We want to sort by id because moving elements about in the DOM will\n\t\t// cause the element to get removed by react as it moves the DOM node. This\n\t\t// causes <iframes/> to re-render which is hella annoying and a perf\n\t\t// drain. By always sorting by 'id' we keep the shapes always in the\n\t\t// same order; but we later use index to set the element's 'z-index'\n\t\t// to change the \"rendered\" position in z-space.\n\n\t\tconst { currentPageId, cullingViewport, erasingIdsSet, editingId } = this\n\n\t\tconst renderingShapes: {\n\t\t\tid: TLShapeId\n\t\t\tindex: number\n\t\t\topacity: number\n\t\t\tisCulled: boolean\n\t\t}[] = []\n\n\t\tconst getShapeToDisplay = (\n\t\t\tid: TLShapeId,\n\t\t\tparentOpacity: number,\n\t\t\tisAncestorErasing: boolean\n\t\t) => {\n\t\t\tconst shape = this.getShapeById(id)\n\n\t\t\tif (!shape) return\n\n\t\t\t// todo: move opacity to a property of shape, rather than a property of props\n\t\t\tlet opacity = (+(shape.props as { opacity: string }).opacity ?? 1) * parentOpacity\n\t\t\tlet isShapeErasing = false\n\n\t\t\tif (!isAncestorErasing && erasingIdsSet.has(id)) {\n\t\t\t\tisShapeErasing = true\n\t\t\t\topacity *= 0.32\n\t\t\t}\n\n\t\t\tconst bounds = this.getMaskedPageBoundsById(id)\n\n\t\t\tif (!bounds) return\n\n\t\t\tconst isCulled = editingId !== id && !cullingViewport.includes(bounds)\n\n\t\t\trenderingShapes.push({ id, index: renderingShapes.length, opacity, isCulled })\n\n\t\t\tthis.getSortedChildren(id).forEach((id) => {\n\t\t\t\tgetShapeToDisplay(id, opacity, isAncestorErasing || isShapeErasing)\n\t\t\t})\n\t\t}\n\n\t\tthis.getSortedChildren(currentPageId).forEach((shapeId) => getShapeToDisplay(shapeId, 1, false))\n\n\t\treturn renderingShapes.sort(sortById)\n\t}\n\n\t/**\n\t * The common bounds of all of the shapes on the page.\n\t *\n\t * @public\n\t */\n\t@computed get allShapesCommonBounds(): Box2d | null {\n\t\tlet commonBounds = null as Box2d | null\n\n\t\tthis.shapeIds.forEach((shapeId) => {\n\t\t\tconst bounds = this.getMaskedPageBoundsById(shapeId)\n\t\t\tif (bounds) {\n\t\t\t\tif (commonBounds) {\n\t\t\t\t\tcommonBounds.expand(bounds)\n\t\t\t\t} else {\n\t\t\t\t\tcommonBounds = bounds.clone()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn commonBounds\n\t}\n\n\t/**\n\t * Get the corners of a shape in page space.\n\t *\n\t * @example\n\t * ```ts\n\t * \tconst corners = app.getPageCorners(myShape)\n\t * ```\n\t *\n\t * @param shape - The shape to get the corners for.\n\t * @public\n\t */\n\tgetPageCorners = (shape: TLShape): Vec2d[] => {\n\t\tconst ancestors = this.getAncestors(shape)\n\t\tconst corners = this.getBounds(shape).corners\n\n\t\tconst transform = Matrix2d.Compose(\n\t\t\t...ancestors.flatMap((s) => [Matrix2d.Translate(s.x, s.y), Matrix2d.Rotate(s.rotation)]),\n\t\t\tMatrix2d.Translate(shape.x, shape.y),\n\t\t\tMatrix2d.Rotate(shape.rotation, 0, 0)\n\t\t)\n\n\t\treturn Matrix2d.applyToPoints(transform, corners)\n\t}\n\n\t/**\n\t * Test whether a point (in page space) will will a shape. This method takes into\n\t * account masks, such as when a shape is the child of a frame and is partially\n\t * clipped by the frame.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.isPointInShape({ x: 100, y: 100 }, myShape)\n\t * ```\n\t *\n\t * @param point - The page point to test.\n\t * @param shape - The shape to test against.\n\t * @public\n\t */\n\tisPointInShape = (point: VecLike, shape: TLShape): boolean => {\n\t\tconst util = this.getShapeUtil(shape)\n\n\t\tconst pageMask = this._pageMaskCache.get(shape.id)\n\n\t\tif (pageMask) {\n\t\t\tconst hit = pointInPolygon(point, pageMask)\n\t\t\tif (!hit) return false\n\t\t}\n\n\t\treturn util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t}\n\n\t/**\n\t * Get the shapes, if any, at a given page point.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getShapesAtPoint({ x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param point - The page point to test.\n\t * @public\n\t */\n\tgetShapesAtPoint = (point: VecLike): TLShape[] => {\n\t\treturn this.sortedShapesArray.filter((shape) => {\n\t\t\tconst pageMask = this._pageMaskCache.get(shape.id)\n\t\t\tif (pageMask) {\n\t\t\t\tconst hasHit = pointInPolygon(point, pageMask)\n\t\t\t\tif (!hasHit) return false\n\t\t\t}\n\n\t\t\treturn this.getShapeUtil(shape).hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t\t})\n\t}\n\n\t/**\n\t * Convert a point in page space to a point in the local space of a shape. For example, if a\n\t * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at\n\t * `{ x: 10, y: 10 }` in the shape's local space.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPointInShapeSpace(myShape, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the point in the local space of.\n\t * @param point - The page point to get in the local space of the shape.\n\t * @public\n\t */\n\tgetPointInShapeSpace = (shape: TLShape, point: VecLike): Vec2d => {\n\t\treturn Matrix2d.applyToPoint(Matrix2d.Inverse(this.getPageTransform(shape)!), point)\n\t}\n\n\t/**\n\t * Convert a delta in page space to a point in the local space of a shape. For example, if a\n\t * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at\n\t * `{ x: 10, y: 10 }` in the shape's local space.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getPointInShapeSpace(myShape.id, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the point in the local space of.\n\t * @param point - The page point to get in the local space of the shape.\n\t * @public\n\t */\n\tgetPointInParentSpace = (shapeId: TLShapeId, point: VecLike): Vec2d => {\n\t\tconst shape = this.getShapeById(shapeId)!\n\t\tif (!shape) {\n\t\t\treturn new Vec2d(0, 0)\n\t\t}\n\t\tif (TLPage.isId(shape.parentId)) return Vec2d.From(point)\n\n\t\tconst parentTransform = this.getPageTransformById(shape.parentId)\n\t\tif (!parentTransform) return Vec2d.From(point)\n\n\t\treturn Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), point)\n\t}\n\n\t/**\n\t * Convert a delta in page space to a delta in the local space of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getDeltaInShapeSpace(myShape, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the delta in the local space of.\n\t * @param delta - The page delta to convert.\n\t * @public\n\t */\n\tgetDeltaInShapeSpace = (shape: TLShape, delta: VecLike): Vec2d => {\n\t\tconst pageTransform = this.getPageTransform(shape)\n\t\tif (!pageTransform) return Vec2d.From(delta)\n\t\treturn Vec2d.Rot(delta, -Matrix2d.Decompose(pageTransform).rotation)\n\t}\n\n\t/**\n\t * Convert a delta in page space to a delta in the parent space of a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getDeltaInParentSpace(myShape, { x: 100, y: 100 })\n\t * ```\n\t *\n\t * @param shape - The shape to get the delta in the parent space of.\n\t * @param delta - The page delta to convert.\n\t * @public\n\t */\n\tgetDeltaInParentSpace = (shape: TLShape, delta: VecLike): Vec2d => {\n\t\tif (TLPage.isId(shape.parentId)) return Vec2d.From(delta)\n\n\t\tconst parent = this.getShapeById(shape.parentId)\n\t\tif (!parent) return Vec2d.From(delta)\n\n\t\treturn this.getDeltaInShapeSpace(parent, delta)\n\t}\n\n\t/**\n\t * For a given set of ids, get a map containing the ids of their parents and the children of those\n\t * parents.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getParentsMappedToChildren(['id1', 'id2', 'id3'])\n\t * ```\n\t *\n\t * @param ids - The ids to get the parents and children of.\n\t * @public\n\t */\n\tgetParentsMappedToChildren = (ids: TLShapeId[]) => {\n\t\tconst shapes = ids.map((id) => this.store.get(id)!)\n\t\tconst parents = new Map<TLParentId, Set<TLShape>>()\n\t\tshapes.forEach((shape) => {\n\t\t\tif (!parents.has(shape.parentId)) {\n\t\t\t\tparents.set(shape.parentId, new Set())\n\t\t\t}\n\t\t\tparents.get(shape.parentId)?.add(shape)\n\t\t})\n\t\treturn parents\n\t}\n\n\t/* -------------------- Viewport -------------------- */\n\n\tupdateScreenBounds() {\n\t\tconst container = this.getContainer()\n\n\t\tif (container) {\n\t\t\tconst rect = container.getBoundingClientRect()\n\t\t\tthis.setScreenBounds({ x: rect.left, y: rect.top, w: rect.width, h: rect.height })\n\t\t}\n\t}\n\n\t@computed get screenBounds() {\n\t\tconst { x, y, w, h } = this.instanceState.screenBounds\n\t\treturn new Box2d(x, y, w, h)\n\t}\n\n\t_screenCenter = computed('_screenCenter', () => {\n\t\treturn this.screenBounds.center\n\t})\n\n\tget screenCenter() {\n\t\treturn this._screenCenter.value\n\t}\n\n\t_viewport = computed('_viewPort', () => {\n\t\tconst { x, y, w, h } = this.screenBounds\n\t\tconst tl = this.screenToPage(x, y)\n\t\tconst br = this.screenToPage(x + w, y + h)\n\t\treturn new Box2d(tl.x, tl.y, br.x - tl.x, br.y - tl.y)\n\t})\n\n\t/** The current viewport in page space. */\n\tget viewport() {\n\t\treturn this._viewport.value\n\t}\n\n\t_cullingViewport = atom('_cullingViewport', new Box2d())\n\n\tupdateCullingViewport() {\n\t\tconst vp = Box2d.ExpandBy(this._viewport.__unsafe__getWithoutCapture(), 100 / this.zoomLevel)\n\t\tconst cv = this._cullingViewport.__unsafe__getWithoutCapture()\n\t\tif (vp.equals(cv)) return\n\t\tthis._cullingViewport.set(vp)\n\t}\n\n\t/** The current viewport in page space. */\n\tget cullingViewport() {\n\t\treturn this._cullingViewport.value\n\t}\n\n\tget pageBounds() {\n\t\treturn this._viewport.value\n\t}\n\n\t_pageCenter = computed('_pageCenter', () => {\n\t\treturn this.viewport.center\n\t})\n\n\tget pageCenter() {\n\t\treturn this._pageCenter.value\n\t}\n\n\t/**\n\t * Convert a point in screen space to a point in page space.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.screenToPage(100, 100)\n\t * ```\n\t *\n\t * @param x - The x coordinate of the point in screen space.\n\t * @param y - The y coordinate of the point in screen space.\n\t * @param camera - The camera to use. Defaults to the current camera.\n\t * @public\n\t */\n\tscreenToPage = (x: number, y: number, z = 0.5, camera: Vec2dModel = this.camera) => {\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(this.instanceId)!\n\t\tconst { x: cx, y: cy, z: cz = 1 } = camera\n\t\treturn {\n\t\t\tx: (x - screenBounds.x) / cz - cx,\n\t\t\ty: (y - screenBounds.y) / cz - cy,\n\t\t\tz,\n\t\t}\n\t}\n\n\t/**\n\t * Convert a point in page space to a point in screen space.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.pageToScreen(100, 100)\n\t * ```\n\t *\n\t * @param x - The x coordinate of the point in screen space.\n\t * @param y - The y coordinate of the point in screen space.\n\t * @param camera - The camera to use. Defaults to the current camera.\n\t * @public\n\t */\n\tpageToScreen = (x: number, y: number, z = 0.5, camera: Vec2dModel = this.camera) => {\n\t\tconst { x: cx, y: cy, z: cz = 1 } = camera\n\t\treturn {\n\t\t\tx: x + cx * cz,\n\t\t\ty: y + cy * cz,\n\t\t\tz,\n\t\t}\n\t}\n\n\t/* Focus Layers */\n\n\tget focusLayerId() {\n\t\treturn this.pageState.focusLayerId ?? this.currentPageId\n\t}\n\n\tget focusLayerShape(): TLShape | undefined {\n\t\tconst id = this.pageState.focusLayerId\n\t\tif (!id) {\n\t\t\treturn\n\t\t}\n\t\treturn this.getShapeById(id)\n\t}\n\n\tpopFocusLayer = () => {\n\t\tconst current = this.pageState.focusLayerId\n\t\tconst focusedShape = current && this.getShapeById(current)\n\n\t\tif (focusedShape) {\n\t\t\t// If we have a focused layer, look for an ancestor of the focused shape that is a group\n\t\t\tconst match = this.findAncestor(focusedShape, (s) => s.type === 'group')\n\t\t\t// If we have an ancestor that can become a focused layer, set it as the focused layer\n\t\t\tthis.setFocusLayer(match?.id ?? null)\n\t\t\tthis.select(focusedShape.id)\n\t\t} else {\n\t\t\t// If there's no focused shape, then clear the focus layer and clear selection\n\t\t\tthis.setFocusLayer(null)\n\t\t\tthis.selectNone()\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the focus layer to the given shape id.\n\t *\n\t * @param next - The next focus layer id or null to reset the focus layer to the page\n\t *\n\t * @public\n\t */\n\tsetFocusLayer = this.history.createCommand(\n\t\t'setFocusLayer',\n\t\t(next: null | TLShapeId) => {\n\t\t\t// When we first click an empty canvas we don't want this to show up in the undo stack\n\t\t\tif (next === null && !this.canUndo) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tconst prev = this.pageState.focusLayerId\n\t\t\treturn { data: { prev, next }, preservesRedoStack: true, squashing: true }\n\t\t},\n\t\t{\n\t\t\tdo: ({ next }) => {\n\t\t\t\tthis.store.update(this.pageState.id, (s) => ({ ...s, focusLayerId: next }))\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.update(this.pageState.id, (s) => ({ ...s, focusLayerId: prev }))\n\t\t\t},\n\t\t\tsquash({ prev }, { next }) {\n\t\t\t\treturn { prev, next }\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Set the hinted shape ids.\n\t *\n\t * @param ids - The ids to set as hinted.\n\t *\n\t * @public\n\t */\n\tsetHintingIds = (ids: TLShapeId[]) => {\n\t\t// always ephemeral\n\t\tthis.store.update(this.pageState.id, (s) => ({ ...s, hintingIds: dedupe(ids) }))\n\t}\n\n\t/**\n\t * The current editing shape's id.\n\t *\n\t * @public\n\t */\n\tget editingId() {\n\t\treturn this.pageState.editingId\n\t}\n\n\t@computed get editingShape() {\n\t\tif (!this.editingId) return null\n\t\treturn this.getShapeById(this.editingId) ?? null\n\t}\n\n\t/**\n\t * Set the current editing id.\n\t *\n\t * @param id - The id of the shape to edit or null to clear the editing id.\n\t *\n\t * @public\n\t */\n\tsetEditingId = (id: TLShapeId | null) => {\n\t\tif (!id) {\n\t\t\tthis.setPageState({ editingId: null })\n\t\t} else {\n\t\t\tif (id !== this.editingId) {\n\t\t\t\tconst shape = this.getShapeById(id)!\n\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\tif (shape && util.canEdit(shape)) {\n\t\t\t\t\tthis.setPageState({ editingId: id, hoveredId: null }, false)\n\t\t\t\t\tconst { viewport } = this\n\t\t\t\t\tconst localEditingBounds = util.getEditingBounds(shape)!\n\t\t\t\t\tconst pageTransform = this.getPageTransformById(id)!\n\t\t\t\t\tconst pageEditingBounds = Box2d.FromPoints(\n\t\t\t\t\t\tMatrix2d.applyToPoints(pageTransform, localEditingBounds.corners)\n\t\t\t\t\t)\n\n\t\t\t\t\tif (!viewport.contains(pageEditingBounds)) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tpageEditingBounds.width > viewport.width ||\n\t\t\t\t\t\t\tpageEditingBounds.height > viewport.height\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.zoomToBounds(\n\t\t\t\t\t\t\t\tpageEditingBounds.minX,\n\t\t\t\t\t\t\t\tpageEditingBounds.minY,\n\t\t\t\t\t\t\t\tpageEditingBounds.width,\n\t\t\t\t\t\t\t\tpageEditingBounds.height\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.centerOnPoint(pageEditingBounds.midX, pageEditingBounds.midY)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\tgetParentIdForNewShapeAtPoint = (point: VecLike, shapeType: TLShapeType) => {\n\t\tconst shapes = this.sortedShapesArray\n\n\t\tfor (let i = shapes.length - 1; i >= 0; i--) {\n\t\t\tconst shape = shapes[i]\n\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\tif (!util.canReceiveNewChildrenOfType(shapeType)) continue\n\t\t\tconst pageBounds = this.getPageBoundsById(shape.id)\n\t\t\tif (!pageBounds) continue\n\t\t\tif (\n\t\t\t\tpageBounds.containsPoint(point) &&\n\t\t\t\tutil.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t\t\t) {\n\t\t\t\treturn shape.id\n\t\t\t}\n\t\t}\n\n\t\treturn this.focusLayerId\n\t}\n\n\tgetDroppingShape = (point: VecLike, droppingShapes: TLShape[] = []) => {\n\t\tconst shapes = this.sortedShapesArray\n\n\t\tfor (let i = shapes.length - 1; i >= 0; i--) {\n\t\t\tconst shape = shapes[i]\n\t\t\t// don't allow dropping a shape on itself or one of it's children\n\t\t\tif (droppingShapes.find((s) => s.id === shape.id || this.hasAncestor(shape, s.id))) continue\n\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\tif (!util.canDropShapes(shape, droppingShapes)) continue\n\t\t\tconst pageBounds = this.getPageBoundsById(shape.id)\n\t\t\tif (!pageBounds) continue\n\t\t\tif (\n\t\t\t\tpageBounds.containsPoint(point) &&\n\t\t\t\tutil.hitTestPoint(shape, this.getPointInShapeSpace(shape, point))\n\t\t\t) {\n\t\t\t\treturn shape\n\t\t\t}\n\t\t}\n\n\t\treturn undefined\n\t}\n\n\t// This returns the node that should be selected when you click on this one, assuming there is nothing\n\t// already selected. It will not return anything higher than or including the current focus layer.\n\tgetOutermostSelectableShape(shape: TLShape, filter?: (shape: TLShape) => boolean): TLShape {\n\t\tlet match = shape\n\t\tlet node = shape as TLShape | undefined\n\t\twhile (node) {\n\t\t\tif (\n\t\t\t\tnode.type === 'group' &&\n\t\t\t\tthis.focusLayerId !== node.id &&\n\t\t\t\t!this.hasAncestor(this.focusLayerShape, node.id) &&\n\t\t\t\t(filter?.(node) ?? true)\n\t\t\t) {\n\t\t\t\tmatch = node\n\t\t\t} else if (this.focusLayerId === node.id) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnode = this.getParentShape(node)\n\t\t}\n\n\t\treturn match\n\t}\n\n\t/* --------------------- Shapes --------------------- */\n\n\t/**\n\t * The app's set of styles.\n\t *\n\t * @public\n\t */\n\tstatic styles = STYLES\n\n\t/**\n\t * The current page bounds of all the selected shapes (Not the same thing as the page bounds of\n\t * the selection bounding box when the selection has been rotated)\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get selectedPageBounds(): Box2d | null {\n\t\tconst {\n\t\t\tpageState: { selectedIds },\n\t\t} = this\n\n\t\tif (selectedIds.length === 0) return null\n\n\t\treturn Box2d.Common(compact(selectedIds.map(this.getPageBoundsById)))\n\t}\n\n\t/** The rotation of the selection bounding box. */\n\t@computed get selectionRotation(): number {\n\t\tconst { selectedIds } = this\n\t\tif (selectedIds.length === 0) {\n\t\t\treturn 0\n\t\t}\n\t\tif (selectedIds.length === 1) {\n\t\t\treturn this.getPageRotationById(this.selectedIds[0])\n\t\t}\n\n\t\tconst allRotations = selectedIds.map((id) => this.getPageRotationById(id) % (Math.PI / 2))\n\t\t// if the rotations are all compatible with each other, return the rotation of any one of them\n\t\tif (allRotations.every((rotation) => Math.abs(rotation - allRotations[0]) < Math.PI / 180)) {\n\t\t\treturn this.getPageRotationById(selectedIds[0])\n\t\t}\n\t\treturn 0\n\t}\n\n\t@computed get selectionBounds(): Box2d | undefined {\n\t\tconst { selectedIds } = this\n\n\t\tif (selectedIds.length === 0) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tconst { selectionRotation } = this\n\t\tif (selectionRotation === 0) {\n\t\t\treturn this.selectedPageBounds!\n\t\t}\n\n\t\tif (selectedIds.length === 1) {\n\t\t\tconst bounds = this.getBounds(this.getShapeById(selectedIds[0])!).clone()\n\t\t\tbounds.point = Matrix2d.applyToPoint(this.getPageTransformById(selectedIds[0])!, bounds.point)\n\t\t\treturn bounds\n\t\t}\n\n\t\t// need to 'un-rotate' all the outlines of the existing nodes so we can fit them inside a box\n\t\tconst allPoints = this.selectedIds\n\t\t\t.flatMap((id) => {\n\t\t\t\tconst pageTransform = this.getPageTransformById(id)\n\t\t\t\tif (!pageTransform) return []\n\t\t\t\treturn this.getOutlineById(id).map((point) => Matrix2d.applyToPoint(pageTransform, point))\n\t\t\t})\n\t\t\t.map((p) => Vec2d.Rot(p, -selectionRotation))\n\t\tconst box = Box2d.FromPoints(allPoints)\n\t\t// now position box so that it's top-left corner is in the right place\n\t\tbox.point = box.point.rot(selectionRotation)\n\t\treturn box\n\t}\n\n\t@computed get selectionPageCenter() {\n\t\tconst { selectionBounds, selectionRotation } = this\n\t\tif (!selectionBounds) return null\n\t\treturn Vec2d.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation)\n\t}\n\n\t/**\n\t * An array containing all of the shapes in the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.shapesArray\n\t * ```\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get shapesArray() {\n\t\treturn Array.from(this.shapeIds).map((id) => this.store.get(id)! as TLShape)\n\t}\n\n\t/**\n\t * An array containing all of the shapes in the current page, sorted in z-index order (accounting\n\t * for nested shapes): e.g. A, B, BA, BB, C.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.sortedShapesArray\n\t * ```\n\t *\n\t * @readonly\n\t * @public\n\t */\n\t@computed get sortedShapesArray(): TLShape[] {\n\t\tconst shapes = new Set(this.shapesArray.sort(sortByIndex))\n\n\t\tconst results: TLShape[] = []\n\n\t\tfunction pushShapeWithDescendants(shape: TLShape): void {\n\t\t\tresults.push(shape)\n\t\t\tshapes.delete(shape)\n\n\t\t\tshapes.forEach((otherShape) => {\n\t\t\t\tif (otherShape.parentId === shape.id) {\n\t\t\t\t\tpushShapeWithDescendants(otherShape)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tshapes.forEach((shape) => {\n\t\t\tconst parent = this.getShapeById(shape.parentId)\n\t\t\tif (!isShape(parent)) {\n\t\t\t\tpushShapeWithDescendants(shape)\n\t\t\t}\n\t\t})\n\n\t\treturn results\n\t}\n\n\t/**\n\t * An array containing all of the currently selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.selectedShapes\n\t * ```\n\t *\n\t * @public\n\t * @readonly\n\t */\n\t@computed get selectedShapes() {\n\t\tconst { selectedIds } = this.pageState\n\t\treturn compact(selectedIds.map((id) => this.store.get(id)))\n\t}\n\n\t/**\n\t * The app's only selected shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.onlySelectedShape\n\t * ```\n\t *\n\t * @returns Null if there is no shape or more than one selected shape, otherwise the selected\n\t *   shape.\n\t * @public\n\t * @readonly\n\t */\n\t@computed get onlySelectedShape() {\n\t\tconst { selectedShapes } = this\n\t\treturn selectedShapes.length === 1 ? selectedShapes[0] : null\n\t}\n\n\t/**\n\t * Get a shape by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getShapeById('box1')\n\t * ```\n\t *\n\t * @param id - The id of the shape to get.\n\t * @public\n\t */\n\tgetShapeById = <T extends TLShape = TLShape>(id: TLParentId): T | undefined => {\n\t\tif (!isShapeId(id)) return undefined\n\t\treturn this.store.get(id) as T\n\t}\n\n\t/**\n\t * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of\n\t * the page.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getParentShape(myShape)\n\t * ```\n\t *\n\t * @public\n\t */\n\tgetParentShape = (shape?: TLShape): TLShape | undefined => {\n\t\tif (shape === undefined || !isShapeId(shape.parentId)) return undefined\n\t\treturn this.store.get(shape.parentId)\n\t}\n\n\t/**\n\t * If siblingShape and targetShape are siblings, this returns targetShape\n\t * If targetShape has an ancestor who is a sibling of siblingShape, this returns that ancestor\n\t * Otherwise, this returns undefined\n\t */\n\tprivate getNearestSiblingShape = (\n\t\tsiblingShape: TLShape,\n\t\ttargetShape: TLShape | undefined\n\t): TLShape | undefined => {\n\t\tif (!targetShape) {\n\t\t\treturn undefined\n\t\t}\n\t\tif (targetShape.parentId === siblingShape.parentId) {\n\t\t\treturn targetShape\n\t\t}\n\n\t\tconst ancestor = this.findAncestor(\n\t\t\ttargetShape,\n\t\t\t(ancestor) => ancestor.parentId === siblingShape.parentId\n\t\t)\n\n\t\treturn ancestor\n\t}\n\n\t/**\n\t * Get the id of the containing page for a given shape.\n\t */\n\tgetParentPageId = (shape?: TLShape): TLPageId | undefined => {\n\t\tif (shape === undefined) return undefined\n\t\tif (TLPage.isId(shape.parentId)) {\n\t\t\treturn shape.parentId\n\t\t} else {\n\t\t\treturn this.getParentPageId(this.getShapeById(shape.parentId))\n\t\t}\n\t}\n\n\t/**\n\t * Get whether the given shape is the descendant of the given page.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.isShapeInPage(myShape)\n\t * \tapp.isShapeInPage(myShape, 'page1')\n\t\n\t * ```\n\t * @param shape - The shape to check.\n\t * @param pageId - The id of the page to check against. Defaults to the current page.\n\t * @public\n\t */\n\tisShapeInPage = (shape: TLShape, pageId = this.currentPageId): boolean => {\n\t\tlet shapeIsInPage = false\n\n\t\tif (shape.parentId === pageId) {\n\t\t\tshapeIsInPage = true\n\t\t} else {\n\t\t\tlet parent = this.getShapeById(shape.parentId)\n\t\t\tisInPageSearch: while (parent) {\n\t\t\t\tif (parent.parentId === pageId) {\n\t\t\t\t\tshapeIsInPage = true\n\t\t\t\t\tbreak isInPageSearch\n\t\t\t\t}\n\t\t\t\tparent = this.getShapeById(parent.parentId)\n\t\t\t}\n\t\t}\n\n\t\treturn shapeIsInPage\n\t}\n\n\t/* --------------------- Styles --------------------- */\n\n\t/**\n\t * A mapping of color ids to CSS color values.\n\t *\n\t * @internal\n\t */\n\tprivate colors: Map<TLColorStyle['id'], string>\n\n\t/**\n\t * A mapping of size ids to size values.\n\t *\n\t * @internal\n\t */\n\tprivate sizes = {\n\t\ts: 2,\n\t\tm: 3.5,\n\t\tl: 5,\n\t\txl: 10,\n\t}\n\n\t/**\n\t * Get the CSS color value for a given color id.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getCssColor('red')\n\t * ```\n\t *\n\t * @param id - The id of the color to get.\n\t * @public\n\t */\n\tgetCssColor = (id: TLColorStyle['id']): string => this.colors.get(id)!\n\n\t/**\n\t * Get the stroke width value for a given size id.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getStrokeWidth('m')\n\t * ```\n\t *\n\t * @param id - The id of the size to get.\n\t * @public\n\t */\n\tgetStrokeWidth = (id: TLSizeStyle['id']): number => this.sizes[id]\n\n\t/* ------------------- Statechart ------------------- */\n\n\t/**\n\t * The id of the current selected tool.\n\t *\n\t * @public\n\t */\n\tget currentToolId(): string {\n\t\tconst activeTool = this.root.current.value\n\t\tlet activeToolId = activeTool?.id\n\n\t\t// Often a tool will transition into one of the following select states after the initial pointerdown: 'translating', 'resizing', 'dragging_handle'\n\t\t// It should then supply the tool id to the `onInteractionEnd` property to tell us which tool initially triggered the interaction.\n\t\t// If tool lock mode is on then tldraw will switch to the given tool id.\n\t\t// If tool lock mode is off then tldraw will switch back to the select tool when the interaction ends.\n\n\t\tif (activeToolId === 'select') {\n\t\t\tconst currentChildState = activeTool?.current.value as any\n\t\t\tactiveToolId = currentChildState?.info?.onInteractionEnd ?? 'select'\n\t\t}\n\n\t\treturn activeToolId ?? 'select'\n\t}\n\n\t/**\n\t * Set the selected tool.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setSelectedTool('hand')\n\t * \tapp.setSelectedTool('hand', { date: Date.now() })\n\t * ```\n\t *\n\t * @param id - The id of the tool to select.\n\t * @param info - Arbitrary data to pass along into the transition.\n\t * @public\n\t */\n\tsetSelectedTool = (id: string, info = {}) => {\n\t\tthis.root.transition(id, info)\n\t\treturn this\n\t}\n\n\t/**\n\t * Get a descendant by its path.\n\t *\n\t * @example\n\t * ```ts\n\t * \tstate.getStateDescendant('select')\n\t * \tstate.getStateDescendant('select.brushing')\n\t * ```\n\t *\n\t * @param path - The descendant's path of state ids, separated by periods.\n\t * @public\n\t */\n\tgetStateDescendant = (path: string): StateNode | undefined => {\n\t\tconst ids = path.split('.').reverse()\n\t\tlet state = this.root as StateNode\n\t\twhile (ids.length > 0) {\n\t\t\tconst id = ids.pop()\n\t\t\tif (!id) return state\n\t\t\tconst childState = state.children?.[id]\n\t\t\tif (!childState) return undefined\n\t\t\tstate = childState\n\t\t}\n\t\treturn state\n\t}\n\n\t/**\n\t * Get whether a certain tool (or other state node) is currently active.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.isIn('select')\n\t * \tapp.isIn('select.brushing')\n\t * ```\n\t *\n\t * @param path - The path of active states, separated by periods.\n\t * @public\n\t */\n\tisIn = (path: string): boolean => {\n\t\tconst ids = path.split('.').reverse()\n\t\tlet state = this.root as StateNode\n\t\twhile (ids.length > 0) {\n\t\t\tconst id = ids.pop()\n\t\t\tif (!id) return true\n\t\t\tconst current = state.current.value\n\t\t\tif (current?.id === id) {\n\t\t\t\tif (ids.length === 0) return true\n\t\t\t\tstate = current\n\t\t\t\tcontinue\n\t\t\t} else return false\n\t\t}\n\t\treturn false\n\t}\n\n\t/**\n\t * Get whether the state node is in any of the given active paths.\n\t *\n\t * @example\n\t * ```ts\n\t * \tstate.isInAny('select', 'erase')\n\t * \tstate.isInAny('select.brushing', 'erase.idle')\n\t * ```\n\t *\n\t * @public\n\t */\n\tisInAny = (...paths: string[]): boolean => {\n\t\treturn paths.some(this.isIn)\n\t}\n\n\t/* --------------------- Inputs --------------------- */\n\n\t/**\n\t * The app's current input state.\n\t *\n\t * @public\n\t */\n\tinputs = {\n\t\t/** The most recent pointer down's position in page space. */\n\t\toriginPagePoint: new Vec2d(),\n\t\t/** The most recent pointer down's position in screen space. */\n\t\toriginScreenPoint: new Vec2d(),\n\t\t/** The previous pointer position in page space. */\n\t\tpreviousPagePoint: new Vec2d(),\n\t\t/** The previous pointer position in screen space. */\n\t\tpreviousScreenPoint: new Vec2d(),\n\t\t/** The most recent pointer position in page space. */\n\t\tcurrentPagePoint: new Vec2d(),\n\t\t/** The most recent pointer position in screen space. */\n\t\tcurrentScreenPoint: new Vec2d(),\n\t\t/** A set containing the currently pressed keys. */\n\t\tkeys: new Set<string>(),\n\t\t/** A set containing the currently pressed buttons. */\n\t\tbuttons: new Set<number>(),\n\t\t/** Whether the input is from a pe. */\n\t\tisPen: false,\n\t\t/** Whether the shift key is currently pressed. */\n\t\tshiftKey: false,\n\t\t/** Whether the control or command key is currently pressed. */\n\t\tctrlKey: false,\n\t\t/** Whether the alt or option key is currently pressed. */\n\t\taltKey: false,\n\t\t/** Whether the user is dragging. */\n\t\tisDragging: false,\n\t\t/** Whether the user is pointing. */\n\t\tisPointing: false,\n\t\t/** Whether the user is pinching. */\n\t\tisPinching: false,\n\t\t/** Whether the user is editing. */\n\t\tisEditing: false,\n\t\t/** Whether the user is panning. */\n\t\tisPanning: false,\n\t\t/** Veclocity of mouse pointer, in pixels per millisecond */\n\t\tpointerVelocity: new Vec2d(),\n\t}\n\n\t/**\n\t * Update the input points from a pointer or pinch event.\n\t *\n\t * @internal\n\t * @param info - The event info.\n\t */\n\tprivate _updateInputsFromEvent = (info: TLPointerEventInfo | TLPinchEventInfo) => {\n\t\tconst { previousScreenPoint, previousPagePoint, currentScreenPoint, currentPagePoint } =\n\t\t\tthis.inputs\n\n\t\tconst { screenBounds } = this.store.unsafeGetWithoutCapture(this.instanceId)!\n\t\tconst { x: sx, y: sy, z: sz } = info.point\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\tpreviousScreenPoint.setTo(currentScreenPoint)\n\t\tpreviousPagePoint.setTo(currentPagePoint)\n\n\t\tconst px = (sx - screenBounds.x) / cz - cx\n\t\tconst py = (sy - screenBounds.y) / cz - cy\n\n\t\tcurrentScreenPoint.set(sx, sy)\n\t\tcurrentPagePoint.set(px, py, sz ?? 0.5)\n\n\t\tthis.inputs.isPen = info.type === 'pointer' && info.isPen\n\n\t\t// Reset velocity on pointer down\n\t\tif (info.name === 'pointer_down') {\n\t\t\tthis.inputs.pointerVelocity = new Vec2d()\n\t\t}\n\n\t\t// todo: We only have to do this if there are multiple users in the document\n\t\tthis.updateUserPresence({ cursor: currentPagePoint.toJson() })\n\t}\n\n\t/* --------------------- Events --------------------- */\n\n\t/**\n\t * A manager for recording multiple click events.\n\t *\n\t * @internal\n\t */\n\tprotected _clickManager = new ClickManager(this)\n\n\t/**\n\t * Prevent a double click event from firing the next time the user clicks\n\t *\n\t * @public\n\t */\n\tcancelDoubleClick = () => {\n\t\tthis._clickManager.cancelDoubleClickTimeout()\n\t}\n\n\t/**\n\t * The previous cursor. Used for restoring the cursor after pan events.\n\t *\n\t * @internal\n\t */\n\tprivate _prevCursor: TLCursorType = 'default'\n\n\tprivate shiftKeyTimeout = -1 as any\n\tprivate setShiftKeyTimeout = () => {\n\t\tthis.inputs.shiftKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Shift',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t})\n\t}\n\tprivate altKeyTimeout = -1 as any\n\tprivate setAltKeyTimeout = () => {\n\t\tthis.inputs.altKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Alt',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t})\n\t}\n\tprivate ctrlKeyTimeout = -1 as any\n\tprivate setCtrlKeyTimeout = () => {\n\t\tthis.inputs.ctrlKey = false\n\t\tthis.dispatch({\n\t\t\ttype: 'keyboard',\n\t\t\tname: 'key_up',\n\t\t\tkey: 'Ctrl',\n\t\t\tshiftKey: this.inputs.shiftKey,\n\t\t\tctrlKey: this.inputs.ctrlKey,\n\t\t\taltKey: this.inputs.altKey,\n\t\t})\n\t}\n\tprivate _restoreToolId = 'select'\n\tprivate _pinchStart = 1\n\tprivate _didPinch = false\n\tprivate _selectedIdsAtPointerDown: TLShapeId[] = []\n\n\t/**\n\t * Dispatch an event to the app.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.dispatch(myPointerEvent)\n\t * ```\n\t *\n\t * @param info - The event info.\n\t * @public\n\t */\n\tdispatch = (info: TLEventInfo): this => {\n\t\t// prevent us from spamming similar event errors if we're crashed.\n\t\t// todo: replace with new readonly mode?\n\t\tif (this.crashingError) return this\n\n\t\tconst { inputs } = this\n\t\tconst { type } = info\n\n\t\tthis.batch(() => {\n\t\t\tif (info.type === 'misc') {\n\t\t\t\tif (info.name === 'blur') {\n\t\t\t\t\tif (this.inputs.isPanning) {\n\t\t\t\t\t\tthis.inputs.isPanning = false\n\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\ttype: this._prevCursor,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (info.shiftKey) {\n\t\t\t\tclearInterval(this.shiftKeyTimeout)\n\t\t\t\tthis.shiftKeyTimeout = -1\n\t\t\t\tinputs.shiftKey = true\n\t\t\t} else if (!info.shiftKey && inputs.shiftKey && this.shiftKeyTimeout === -1) {\n\t\t\t\tthis.shiftKeyTimeout = setTimeout(this.setShiftKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tif (info.altKey) {\n\t\t\t\tclearInterval(this.altKeyTimeout)\n\t\t\t\tthis.altKeyTimeout = -1\n\t\t\t\tinputs.altKey = true\n\t\t\t} else if (!info.altKey && inputs.altKey && this.altKeyTimeout === -1) {\n\t\t\t\tthis.altKeyTimeout = setTimeout(this.setAltKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tif (info.ctrlKey) {\n\t\t\t\tclearInterval(this.ctrlKeyTimeout)\n\t\t\t\tthis.ctrlKeyTimeout = -1\n\t\t\t\tinputs.ctrlKey = true\n\t\t\t} else if (!info.ctrlKey && inputs.ctrlKey && this.ctrlKeyTimeout === -1) {\n\t\t\t\tthis.ctrlKeyTimeout = setTimeout(this.setCtrlKeyTimeout, 150)\n\t\t\t}\n\n\t\t\tconst { originPagePoint, originScreenPoint, currentPagePoint, currentScreenPoint } = inputs\n\n\t\t\tif (!inputs.isPointing) {\n\t\t\t\tinputs.isDragging = false\n\t\t\t}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'pinch': {\n\t\t\t\t\tthis._updateInputsFromEvent(info)\n\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'pinch_start': {\n\t\t\t\t\t\t\tif (inputs.isPinching) return\n\n\t\t\t\t\t\t\tif (!inputs.isEditing) {\n\t\t\t\t\t\t\t\tthis._pinchStart = this.camera.z\n\t\t\t\t\t\t\t\tif (!this._selectedIdsAtPointerDown.length) {\n\t\t\t\t\t\t\t\t\tthis._selectedIdsAtPointerDown = this.selectedIds.slice()\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis._didPinch = true\n\n\t\t\t\t\t\t\t\tinputs.isPinching = true\n\n\t\t\t\t\t\t\t\tthis.interrupt()\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pinch': {\n\t\t\t\t\t\t\tif (!inputs.isPinching) return\n\n\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\tpoint: { x, y, z = 1 },\n\t\t\t\t\t\t\t\tdelta: { x: dx, y: dy },\n\t\t\t\t\t\t\t} = info\n\n\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\tcamera: { x: cx, y: cy, z: cz },\n\t\t\t\t\t\t\t} = this\n\n\t\t\t\t\t\t\tconst zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, z))\n\n\t\t\t\t\t\t\tthis.setCamera(\n\t\t\t\t\t\t\t\tcx + dx / cz - x / cz + x / zoom,\n\t\t\t\t\t\t\t\tcy + dy / cz - y / cz + y / zoom,\n\t\t\t\t\t\t\t\tzoom\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pinch_end': {\n\t\t\t\t\t\t\tif (!inputs.isPinching) return this\n\n\t\t\t\t\t\t\tinputs.isPinching = false\n\t\t\t\t\t\t\tconst { _selectedIdsAtPointerDown } = this\n\t\t\t\t\t\t\tthis.setSelectedIds(this._selectedIdsAtPointerDown, true)\n\t\t\t\t\t\t\tthis._selectedIdsAtPointerDown = []\n\n\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\tcamera: { x: cx, y: cy, z: cz },\n\t\t\t\t\t\t\t} = this\n\n\t\t\t\t\t\t\tlet zoom: number | undefined\n\n\t\t\t\t\t\t\tif (cz > 0.9 && cz < 1.05) {\n\t\t\t\t\t\t\t\tzoom = 1\n\t\t\t\t\t\t\t} else if (cz > 0.49 && cz < 0.505) {\n\t\t\t\t\t\t\t\tzoom = 0.5\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (cz > this._pinchStart - 0.1 && cz < this._pinchStart + 0.05) {\n\t\t\t\t\t\t\t\tzoom = this._pinchStart\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (zoom !== undefined) {\n\t\t\t\t\t\t\t\tconst { x, y } = this.screenCenter\n\t\t\t\t\t\t\t\tthis.animateCamera(\n\t\t\t\t\t\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\t\t\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\t\t\t\t\t\tzoom,\n\t\t\t\t\t\t\t\t\t{ duration: 100 }\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this._didPinch) {\n\t\t\t\t\t\t\t\tthis._didPinch = false\n\t\t\t\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\t\t\t\tif (!this._didPinch) {\n\t\t\t\t\t\t\t\t\t\tthis.setSelectedIds(_selectedIdsAtPointerDown, true)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn // Stop here!\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcase 'wheel': {\n\t\t\t\t\tif (this._viewportAnimation || this.isMenuOpen) {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (inputs.ctrlKey) {\n\t\t\t\t\t\t\t// todo: Start or update the zoom end interval\n\n\t\t\t\t\t\t\t// If the alt or ctrl keys are pressed,\n\t\t\t\t\t\t\t// zoom or pan the camera and then return.\n\t\t\t\t\t\t\tconst { x, y } = this.inputs.currentScreenPoint\n\t\t\t\t\t\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\t\t\t\t\t\tconst zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, cz + (info.delta.z ?? 0) * cz))\n\n\t\t\t\t\t\t\tthis.setCamera(\n\t\t\t\t\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\t\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\t\t\t\t\tzoom\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t// We want to return here because none of the states in our\n\t\t\t\t\t\t\t// statechart should respond to this event (a camera zoom)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.pan(info.delta.x, info.delta.y)\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tinputs.isPointing &&\n\t\t\t\t\t\t\t!inputs.isDragging &&\n\t\t\t\t\t\t\tVec2d.Dist(\n\t\t\t\t\t\t\t\toriginScreenPoint,\n\t\t\t\t\t\t\t\tthis.pageToScreen(currentScreenPoint.x, currentScreenPoint.y)\n\t\t\t\t\t\t\t) > DRAG_DISTANCE\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tinputs.isDragging = true\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Important!\n\t\t\t\t\t\t// Before we handle the wheel event, first handle the event\n\t\t\t\t\t\t// as a pointer move.\n\n\t\t\t\t\t\tthis.dispatch({\n\t\t\t\t\t\t\ttype: 'pointer',\n\t\t\t\t\t\t\ttarget: 'canvas',\n\t\t\t\t\t\t\tname: 'pointer_move',\n\t\t\t\t\t\t\tpoint: currentScreenPoint,\n\t\t\t\t\t\t\tpointerId: 0,\n\t\t\t\t\t\t\tctrlKey: info.ctrlKey,\n\t\t\t\t\t\t\taltKey: info.altKey,\n\t\t\t\t\t\t\tshiftKey: info.shiftKey,\n\t\t\t\t\t\t\tbutton: 0,\n\t\t\t\t\t\t\tisPen: this.isPenMode ?? false,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'pointer': {\n\t\t\t\t\t// If we're pinching, return\n\t\t\t\t\tif (inputs.isPinching) return\n\n\t\t\t\t\tthis._updateInputsFromEvent(info)\n\n\t\t\t\t\tconst { isPen } = info\n\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'pointer_down': {\n\t\t\t\t\t\t\tthis._selectedIdsAtPointerDown = this.selectedIds.slice()\n\n\t\t\t\t\t\t\t// Add the button from the buttons set\n\t\t\t\t\t\t\tinputs.buttons.add(info.button)\n\n\t\t\t\t\t\t\tinputs.isPointing = true\n\t\t\t\t\t\t\tinputs.isDragging = false\n\n\t\t\t\t\t\t\tif (this.isPenMode) {\n\t\t\t\t\t\t\t\tif (!isPen) {\n\t\t\t\t\t\t\t\t\t// decrement the remaining taps before exiting pen mode\n\t\t\t\t\t\t\t\t\tthis._touchEventsRemainingBeforeExitingPenMode--\n\t\t\t\t\t\t\t\t\tif (this._touchEventsRemainingBeforeExitingPenMode === 0) {\n\t\t\t\t\t\t\t\t\t\tthis.setPenMode(true)\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// reset the remaining taps before exiting pen mode\n\t\t\t\t\t\t\t\t\tthis._touchEventsRemainingBeforeExitingPenMode = 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (isPen) {\n\t\t\t\t\t\t\t\t\tthis.setPenMode(true)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (info.button === 5) {\n\t\t\t\t\t\t\t\t// Eraser button activates eraser\n\t\t\t\t\t\t\t\tthis._restoreToolId = this.currentToolId\n\t\t\t\t\t\t\t\tthis.complete()\n\t\t\t\t\t\t\t\tthis.setSelectedTool('eraser')\n\t\t\t\t\t\t\t} else if (info.button === 1) {\n\t\t\t\t\t\t\t\t// Middle mouse pan activates panning\n\t\t\t\t\t\t\t\tif (!this.inputs.isPanning) {\n\t\t\t\t\t\t\t\t\tthis._prevCursor = this.instanceState.cursor.type\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = true\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this.inputs.isPanning) {\n\t\t\t\t\t\t\t\tthis.stopCameraAnimation()\n\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\ttype: 'grabbing',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\treturn this\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toriginScreenPoint.setTo(currentScreenPoint)\n\t\t\t\t\t\t\toriginPagePoint.setTo(currentPagePoint)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_move': {\n\t\t\t\t\t\t\t// If the user is in pen mode, but the pointer is not a pen, stop here.\n\t\t\t\t\t\t\tif (!isPen && this.isPenMode) {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this.inputs.isPanning && this.inputs.isPointing) {\n\t\t\t\t\t\t\t\t// Handle panning\n\t\t\t\t\t\t\t\tconst { currentScreenPoint, previousScreenPoint } = this.inputs\n\t\t\t\t\t\t\t\tconst delta = Vec2d.Sub(currentScreenPoint, previousScreenPoint)\n\t\t\t\t\t\t\t\tthis.pan(delta.x, delta.y)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tinputs.isPointing &&\n\t\t\t\t\t\t\t\t!inputs.isDragging &&\n\t\t\t\t\t\t\t\tVec2d.Dist(originScreenPoint, currentScreenPoint) > DRAG_DISTANCE\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t// Start dragging\n\t\t\t\t\t\t\t\tinputs.isDragging = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'pointer_up': {\n\t\t\t\t\t\t\t// Remove the button from the buttons set\n\t\t\t\t\t\t\tinputs.buttons.delete(info.button)\n\n\t\t\t\t\t\t\tinputs.isPointing = false\n\t\t\t\t\t\t\tinputs.isDragging = false\n\n\t\t\t\t\t\t\tif (this.isMenuOpen) {\n\t\t\t\t\t\t\t\t// Surpressing pointerup here as <ContextMenu/> doesn't seem to do what we what here.\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!isPen && this.isPenMode) {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (inputs.isPanning) {\n\t\t\t\t\t\t\t\tif (info.button === 1) {\n\t\t\t\t\t\t\t\t\tif (!this.inputs.keys.has(' ')) {\n\t\t\t\t\t\t\t\t\t\tinputs.isPanning = false\n\n\t\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\t\tfriction: HAND_TOOL_FRICTION,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\t\t\ttype: this._prevCursor,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\t\tfriction: HAND_TOOL_FRICTION,\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\t\t\ttype: 'grab',\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (info.button === 0) {\n\t\t\t\t\t\t\t\t\tthis.slideCamera({\n\t\t\t\t\t\t\t\t\t\tspeed: Math.min(2, this.inputs.pointerVelocity.len()),\n\t\t\t\t\t\t\t\t\t\tdirection: this.inputs.pointerVelocity,\n\t\t\t\t\t\t\t\t\t\tfriction: HAND_TOOL_FRICTION,\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\t\ttype: 'grab',\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (info.button === 5) {\n\t\t\t\t\t\t\t\t\t// Eraser button activates eraser\n\t\t\t\t\t\t\t\t\tthis.complete()\n\t\t\t\t\t\t\t\t\tthis.setSelectedTool(this._restoreToolId)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'keyboard': {\n\t\t\t\t\tswitch (info.name) {\n\t\t\t\t\t\tcase 'key_down': {\n\t\t\t\t\t\t\t// Ignore key presses after the first one\n\t\t\t\t\t\t\tif (inputs.keys.has(info.key)) {\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Add the key from the keys set\n\t\t\t\t\t\t\tinputs.keys.add(info.key)\n\n\t\t\t\t\t\t\t// If the space key is pressed (but meta / control isn't!) activate panning\n\t\t\t\t\t\t\tif (!info.ctrlKey && info.key === ' ') {\n\t\t\t\t\t\t\t\tif (!this.inputs.isPanning) {\n\t\t\t\t\t\t\t\t\tthis._prevCursor = this.instanceState.cursor.type\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = true\n\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\ttype: this.inputs.isPointing ? 'grabbing' : 'grab',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase 'key_up': {\n\t\t\t\t\t\t\t// Remove the key from the keys set\n\t\t\t\t\t\t\tinputs.keys.delete(info.key)\n\n\t\t\t\t\t\t\tif (info.key === ' ' && !this.inputs.buttons.has(1)) {\n\t\t\t\t\t\t\t\tthis.inputs.isPanning = false\n\t\t\t\t\t\t\t\tthis.setCursor({\n\t\t\t\t\t\t\t\t\ttype: this._prevCursor,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Correct the info name for right / middle clicks\n\t\t\tif (info.type === 'pointer') {\n\t\t\t\tif (info.button === 1) {\n\t\t\t\t\tinfo.name = 'middle_click'\n\t\t\t\t} else if (info.button === 2) {\n\t\t\t\t\tinfo.name = 'right_click'\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If a pointer event, send the event to the click manager.\n\t\t\tif (info.type === 'pointer' && info.isPen === this.isPenMode) {\n\t\t\t\tswitch (info.name) {\n\t\t\t\t\tcase 'pointer_down': {\n\t\t\t\t\t\tconst otherEvent = this._clickManager.transformPointerDownEvent(info)\n\t\t\t\t\t\tif (info.name !== otherEvent.name) {\n\t\t\t\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\t\t\t\tthis.emit('event', info)\n\t\t\t\t\t\t\tthis.root.handleEvent(otherEvent)\n\t\t\t\t\t\t\tthis.emit('event', otherEvent)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pointer_up': {\n\t\t\t\t\t\tconst otherEvent = this._clickManager.transformPointerUpEvent(info)\n\t\t\t\t\t\tif (info.name !== otherEvent.name) {\n\t\t\t\t\t\t\tthis.root.handleEvent(info)\n\t\t\t\t\t\t\tthis.emit('event', info)\n\t\t\t\t\t\t\tthis.root.handleEvent(otherEvent)\n\t\t\t\t\t\t\tthis.emit('event', otherEvent)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tcase 'pointer_move': {\n\t\t\t\t\t\tthis._clickManager.handleMove()\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Send the event to the statechart. It will be handled by all\n\t\t\t// active states, starting at the root.\n\t\t\tthis.root.handleEvent(info)\n\t\t\tthis.emit('event', info)\n\t\t})\n\n\t\treturn this\n\t}\n\n\treplaceStoreContentsWithRecordsForOtherDocument(records: TLRecord[]) {\n\t\ttransact(() => {\n\t\t\tthis.store.clear()\n\t\t\tthis.store.put(records, 'initialize')\n\t\t\tthis.store.ensureStoreIsUsable()\n\t\t\tthis.history.clear()\n\t\t\tthis.updateScreenBounds()\n\t\t\tthis.updateCullingViewport()\n\n\t\t\tconst bounds = this.allShapesCommonBounds\n\t\t\tif (bounds) {\n\t\t\t\tthis.zoomToBounds(bounds.minX, bounds.minY, bounds.width, bounds.height)\n\t\t\t}\n\t\t})\n\t}\n\n\tgetContent = (ids: TLShapeId[] = this.selectedIds): TLClipboardModel | undefined => {\n\t\tif (!ids) return\n\t\tif (ids.length === 0) return\n\n\t\tconst pageTransforms: Record<string, Matrix2dModel> = {}\n\n\t\tlet shapes = dedupe(\n\t\t\tids\n\t\t\t\t.map((id) => this.getShapeById(id) as TLShape)\n\t\t\t\t.sort(sortByIndex)\n\t\t\t\t.flatMap((shape) => {\n\t\t\t\t\tconst allShapes = [shape]\n\t\t\t\t\tthis.visitDescendants(shape.id, (descendant) => {\n\t\t\t\t\t\tallShapes.push(this.getShapeById(descendant) as TLShape)\n\t\t\t\t\t})\n\t\t\t\t\treturn allShapes\n\t\t\t\t})\n\t\t)\n\n\t\tshapes = shapes.map((shape) => {\n\t\t\tshape = structuredClone(shape) as typeof shape\n\n\t\t\tpageTransforms[shape.id] = this.getPageTransformById(shape.id)!\n\n\t\t\tif (!TLArrowShapeDef.is(shape)) return shape\n\t\t\tif (shape.props.start.type === 'binding') {\n\t\t\t\tconst boundId = shape.props.start.boundShapeId\n\t\t\t\tif (!shapes.find((s) => s.id === boundId)) {\n\t\t\t\t\tconst { start } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\tshape.props.start = {\n\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\tx: start.x,\n\t\t\t\t\t\ty: start.y,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (shape.props.end.type === 'binding') {\n\t\t\t\tconst boundId = shape.props.end.boundShapeId\n\t\t\t\tif (!shapes.find((s) => s.id === boundId)) {\n\t\t\t\t\tconst { end } = getArrowTerminalsInArrowSpace(this, shape)\n\t\t\t\t\tshape.props.end = {\n\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\tx: end.x,\n\t\t\t\t\t\ty: end.y,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn shape\n\t\t})\n\n\t\tconst rootShapeIds: TLShapeId[] = []\n\n\t\tshapes.forEach((shape) => {\n\t\t\tif (shapes.find((s) => s.id === shape.parentId) === undefined) {\n\t\t\t\t// Need to get page point and rotation of the shape because shapes in\n\t\t\t\t// groups use local position/rotation\n\n\t\t\t\tconst pagePoint = this.getPagePointById(shape.id)!\n\t\t\t\tconst pageRotation = this.getPageRotationById(shape.id)!\n\t\t\t\tshape.x = pagePoint.x\n\t\t\t\tshape.y = pagePoint.y\n\t\t\t\tshape.rotation = pageRotation\n\t\t\t\tshape.parentId = this.currentPageId\n\n\t\t\t\trootShapeIds.push(shape.id)\n\t\t\t}\n\t\t})\n\n\t\tconst assetsSet = new Set<TLAssetId>()\n\n\t\tshapes.forEach((shape) => {\n\t\t\tif ('assetId' in shape.props) {\n\t\t\t\tif (shape.props.assetId !== null) {\n\t\t\t\t\tassetsSet.add(shape.props.assetId)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn {\n\t\t\tshapes,\n\t\t\trootShapeIds,\n\t\t\tschema: this.store.schema.serialize(),\n\t\t\tassets: compact(Array.from(assetsSet).map((id) => this.getAssetById(id))),\n\t\t}\n\t}\n\n\t/* --------------------- Commands --------------------- */\n\n\tputContent = (\n\t\tcontent: TLClipboardModel,\n\t\toptions: {\n\t\t\tpoint?: VecLike\n\t\t\tselect?: boolean\n\t\t\tpreservePosition?: boolean\n\t\t\tpreserveIds?: boolean\n\t\t} = {}\n\t) => {\n\t\tif (this.isReadOnly) return\n\n\t\tif (!content.schema) {\n\t\t\tthrow Error('Could not put content: content is missing a schema.')\n\t\t}\n\n\t\tconst { select = false, preserveIds = false, preservePosition = false } = options\n\t\tlet { point = undefined } = options\n\n\t\t// decide on a parent for the put shapes; if the parent is among the put shapes(?) then use its parent\n\n\t\tconst { currentPageId } = this\n\t\tconst { assets, shapes, rootShapeIds } = content\n\n\t\tconst idMap = new Map<any, TLShapeId>(shapes.map((shape) => [shape.id, createShapeId()]))\n\n\t\t// By default, the paste parent will be the current page.\n\t\tlet pasteParentId = this.currentPageId as TLPageId | TLShapeId\n\t\tlet lowestDepth = Infinity\n\t\tlet lowestAncestors: TLShape[] = []\n\n\t\t// Among the selected shapes, find the shape with the fewest ancestors and use its first ancestor.\n\t\tfor (const shape of this.selectedShapes) {\n\t\t\tif (lowestDepth === 0) break\n\n\t\t\tconst ancestors = this.getAncestors(shape)\n\t\t\tif (shape.type === 'frame') ancestors.push(shape)\n\n\t\t\tconst depth = shape.type === 'frame' ? ancestors.length + 1 : ancestors.length\n\n\t\t\tif (depth < lowestDepth) {\n\t\t\t\tlowestDepth = depth\n\t\t\t\tlowestAncestors = ancestors\n\t\t\t\tpasteParentId = shape.type === 'frame' ? shape.id : shape.parentId\n\t\t\t} else if (depth === lowestDepth) {\n\t\t\t\tif (lowestAncestors.length !== ancestors.length) {\n\t\t\t\t\tthrow Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`)\n\t\t\t\t}\n\n\t\t\t\tif (lowestAncestors.length === 0) {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t\tfor (let i = 0; i < lowestAncestors.length; i++) {\n\t\t\t\t\t\tif (ancestors[i] !== lowestAncestors[i]) break\n\t\t\t\t\t\tpasteParentId = ancestors[i].id\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet isDuplicating = false\n\n\t\tif (!TLPage.isId(pasteParentId)) {\n\t\t\tconst parent = this.getShapeById(pasteParentId)\n\t\t\tif (parent) {\n\t\t\t\tif (!this.viewport.includes(this.getPageBounds(parent)!)) {\n\t\t\t\t\tpasteParentId = currentPageId\n\t\t\t\t} else {\n\t\t\t\t\tif (rootShapeIds.length === 1) {\n\t\t\t\t\t\tconst rootShape = shapes.find((s) => s.id === rootShapeIds[0])!\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tTLFrameShapeDef.is(parent) &&\n\t\t\t\t\t\t\tTLFrameShapeDef.is(rootShape) &&\n\t\t\t\t\t\t\trootShape.props.w === parent?.props.w &&\n\t\t\t\t\t\t\trootShape.props.h === parent?.props.h\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisDuplicating = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpasteParentId = currentPageId\n\t\t\t}\n\t\t}\n\n\t\tif (!isDuplicating) {\n\t\t\tisDuplicating = idMap.has(pasteParentId)\n\t\t}\n\n\t\tif (isDuplicating) {\n\t\t\tpasteParentId = this.getShapeById(pasteParentId)!.parentId\n\t\t}\n\n\t\tlet index = this.getHighestIndexForParent(pasteParentId)\n\n\t\tconst rootShapes: TLShape[] = []\n\n\t\tconst newShapes: TLShapePartial[] = shapes.map((shape): TLShape => {\n\t\t\tlet newShape: TLShape\n\n\t\t\tif (preserveIds) {\n\t\t\t\tnewShape = deepCopy(shape)\n\t\t\t\tidMap.set(shape.id, shape.id)\n\t\t\t} else {\n\t\t\t\tconst id = idMap.get(shape.id)!\n\n\t\t\t\t// Create the new shape (new except for the id)\n\t\t\t\tnewShape = deepCopy({ ...shape, id })\n\t\t\t}\n\n\t\t\tif (rootShapeIds.includes(shape.id)) {\n\t\t\t\tnewShape.parentId = currentPageId\n\t\t\t\trootShapes.push(newShape)\n\t\t\t}\n\n\t\t\t// Assign the child to its new parent.\n\n\t\t\t// If the child's parent is among the putting shapes, then assign\n\t\t\t// it to the new parent's id.\n\t\t\tif (idMap.has(newShape.parentId)) {\n\t\t\t\tnewShape.parentId = idMap.get(shape.parentId)!\n\t\t\t} else {\n\t\t\t\trootShapeIds.push(newShape.id)\n\t\t\t\t// newShape.parentId = pasteParentId\n\t\t\t\tnewShape.index = index\n\t\t\t\tindex = getIndexAbove(index)\n\t\t\t}\n\n\t\t\tif (TLArrowShapeDef.is(newShape)) {\n\t\t\t\tif (newShape.props.start.type === 'binding') {\n\t\t\t\t\tconst mappedId = idMap.get(newShape.props.start.boundShapeId)\n\t\t\t\t\tnewShape.props.start = mappedId\n\t\t\t\t\t\t? { ...newShape.props.start, boundShapeId: mappedId }\n\t\t\t\t\t\t: // this shouldn't happen, if you copy an arrow but not it's bound shape it should\n\t\t\t\t\t\t  // convert the binding to a point at the time of copying\n\t\t\t\t\t\t  { type: 'point', x: 0, y: 0 }\n\t\t\t\t}\n\t\t\t\tif (newShape.props.end.type === 'binding') {\n\t\t\t\t\tconst mappedId = idMap.get(newShape.props.end.boundShapeId)\n\t\t\t\t\tnewShape.props.end = mappedId\n\t\t\t\t\t\t? { ...newShape.props.end, boundShapeId: mappedId }\n\t\t\t\t\t\t: // this shouldn't happen, if you copy an arrow but not it's bound shape it should\n\t\t\t\t\t\t  // convert the binding to a point at the time of copying\n\t\t\t\t\t\t  { type: 'point', x: 0, y: 0 }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newShape\n\t\t})\n\n\t\tif (newShapes.length + this.shapeIds.size > MAX_SHAPES_PER_PAGE) {\n\t\t\t// There's some complexity here involving children\n\t\t\t// that might be created without their parents, so\n\t\t\t// if we're going over the limit then just don't paste.\n\t\t\talertMaxShapes(this)\n\t\t\treturn this\n\t\t}\n\n\t\t// Migrate the new shapes\n\n\t\tlet assetsToCreate: TLAsset[] = []\n\n\t\tif (assets) {\n\t\t\tfor (let i = 0; i < assets.length; i++) {\n\t\t\t\tconst asset = assets[i]\n\t\t\t\tconst result = this.store.schema.migratePersistedRecord(asset, content.schema)\n\t\t\t\tif (result.type === 'success') {\n\t\t\t\t\tassets[i] = result.value as TLAsset\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error(\n\t\t\t\t\t\t`Could not put content: could not migrate content for asset:\\n${JSON.stringify(\n\t\t\t\t\t\t\tasset,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t2\n\t\t\t\t\t\t)}`\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst assetsToUpdate: (TLImageAsset | TLVideoAsset)[] = []\n\n\t\t\tassetsToCreate = assets\n\t\t\t\t.filter((asset) => !this.store.has(asset.id))\n\t\t\t\t.map((asset) => {\n\t\t\t\t\tif (asset.type === 'image' || asset.type === 'video') {\n\t\t\t\t\t\tif (asset.props.src && asset.props.src?.startsWith('data:image')) {\n\t\t\t\t\t\t\tassetsToUpdate.push(structuredClone(asset))\n\t\t\t\t\t\t\tasset.props.src = null\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassetsToUpdate.push(structuredClone(asset))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn asset\n\t\t\t\t})\n\n\t\t\tPromise.allSettled(\n\t\t\t\tassetsToUpdate.map(async (asset) => {\n\t\t\t\t\tconst file = await dataUrlToFile(\n\t\t\t\t\t\tasset.props.src!,\n\t\t\t\t\t\tasset.props.name,\n\t\t\t\t\t\tasset.props.mimeType ?? 'image/png'\n\t\t\t\t\t)\n\n\t\t\t\t\tconst newAsset = await this.onCreateAssetFromFile(file)\n\n\t\t\t\t\treturn [asset, newAsset] as const\n\t\t\t\t})\n\t\t\t).then((assets) => {\n\t\t\t\tthis.updateAssets(\n\t\t\t\t\tcompact(\n\t\t\t\t\t\tassets.map((result) =>\n\t\t\t\t\t\t\tresult.status === 'fulfilled'\n\t\t\t\t\t\t\t\t? { ...result.value[1], id: result.value[0].id }\n\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\n\t\tfor (let i = 0; i < newShapes.length; i++) {\n\t\t\tconst shape = newShapes[i] as TLShape\n\t\t\tconst result = this.store.schema.migratePersistedRecord(shape, content.schema)\n\t\t\tif (result.type === 'success') {\n\t\t\t\tnewShapes[i] = result.value as TLShape\n\t\t\t} else {\n\t\t\t\tthrow Error(\n\t\t\t\t\t`Could not put content: could not migrate content for shape:\\n${JSON.stringify(\n\t\t\t\t\t\tshape,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2\n\t\t\t\t\t)}`\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\tthis.batch(() => {\n\t\t\t// Create any assets that need to be created\n\t\t\tif (assetsToCreate.length > 0) {\n\t\t\t\tthis.createAssets(assetsToCreate)\n\t\t\t}\n\n\t\t\t// Create the shapes with root shapes as children of the page\n\t\t\tthis.createShapes(newShapes, select)\n\n\t\t\t// And then, if needed, reparent the root shapes to the paste parent\n\t\t\tif (pasteParentId !== currentPageId) {\n\t\t\t\tthis.reparentShapes(\n\t\t\t\t\trootShapes.map((s) => s.id),\n\t\t\t\t\tpasteParentId\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tconst newCreatedShapes = newShapes.map((s) => this.getShapeById(s.id)!)\n\t\t\tconst bounds = Box2d.Common(newCreatedShapes.map((s) => this.getPageBounds(s)!))\n\n\t\t\tif (point === undefined) {\n\t\t\t\tif (!TLPage.isId(pasteParentId)) {\n\t\t\t\t\t// Put the shapes in the middle of the (on screen) parent\n\t\t\t\t\tconst shape = this.getShapeById(pasteParentId)!\n\t\t\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\t\t\tpoint = util.center(shape)\n\t\t\t\t} else {\n\t\t\t\t\tif (preservePosition || this.viewport.includes(Box2d.From(bounds))) {\n\t\t\t\t\t\t// Otherwise, put shapes where they used to be\n\t\t\t\t\t\tpoint = bounds.center\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If the old bounds are outside of the viewport...\n\t\t\t\t\t\t// put the shapes in the middle of the viewport\n\t\t\t\t\t\tpoint = this.viewport.center\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (rootShapes.length === 1) {\n\t\t\t\tconst onlyRoot = rootShapes[0] as TLFrameShape\n\t\t\t\t// If the old bounds are in the viewport...\n\t\t\t\tif (onlyRoot.type === 'frame') {\n\t\t\t\t\twhile (\n\t\t\t\t\t\tthis.getShapesAtPoint(point).some(\n\t\t\t\t\t\t\t(shape) =>\n\t\t\t\t\t\t\t\tTLFrameShapeDef.is(shape) &&\n\t\t\t\t\t\t\t\tshape.props.w === onlyRoot.props.w &&\n\t\t\t\t\t\t\t\tshape.props.h === onlyRoot.props.h\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tpoint.x += bounds.w + 16\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.updateShapes(\n\t\t\t\trootShapes.map((s) => {\n\t\t\t\t\tconst delta = {\n\t\t\t\t\t\tx: (s.x ?? 0) - (bounds.x + bounds.w / 2),\n\t\t\t\t\t\ty: (s.y ?? 0) - (bounds.y + bounds.h / 2),\n\t\t\t\t\t}\n\n\t\t\t\t\treturn { id: s.id, type: s.type, x: point!.x + delta.x, y: point!.y + delta.y }\n\t\t\t\t})\n\t\t\t)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/* --------------------- Shapes --------------------- */\n\n\t/**\n\t * Get a unique id for a shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.createShapeId()\n\t * \tapp.createShapeId('box1')\n\t * ```\n\t *\n\t * @param id - The id to use.\n\t * @public\n\t */\n\tcreateShapeId(id?: string) {\n\t\treturn id ? createCustomShapeId(id) : createShapeId()\n\t}\n\n\tgetHighestIndexForParent(parentId: TLShapeId | TLPageId) {\n\t\tconst children = this._parentsToChildrenWithIndexes.value[parentId]\n\n\t\tif (!children || children.length === 0) {\n\t\t\treturn 'a1'\n\t\t}\n\t\treturn getIndexAbove(children[children.length - 1][1])\n\t}\n\n\t/**\n\t * Create shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.createShapes([{ id: \"box1\", type: \"box\" }]\n\t * ```\n\t *\n\t * @param partials - The shape partials to create.\n\t * @param select - Whether to select the created shapes. Defaults to false.\n\t * @public\n\t */\n\tcreateShapes = this.history.createCommand(\n\t\t'createShapes',\n\t\t(partials: TLShapePartial[], select = false) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (partials.length <= 0) return null\n\n\t\t\tconst { shapeIds, selectedIds } = this\n\n\t\t\tconst prevSelectedIds = select ? selectedIds : undefined\n\n\t\t\tconst maxShapesReached = partials.length + shapeIds.size > MAX_SHAPES_PER_PAGE\n\n\t\t\tif (maxShapesReached) {\n\t\t\t\talertMaxShapes(this)\n\t\t\t}\n\n\t\t\tconst partialsToCreate = maxShapesReached\n\t\t\t\t? partials.slice(0, MAX_SHAPES_PER_PAGE - shapeIds.size)\n\t\t\t\t: partials\n\n\t\t\tif (partialsToCreate.length === 0) return null\n\n\t\t\treturn {\n\t\t\t\tdata: {\n\t\t\t\t\tprevSelectedIds,\n\t\t\t\t\tpartials: partialsToCreate,\n\t\t\t\t\tselect,\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ partials, select }) => {\n\t\t\t\tconst { focusLayerId } = this\n\n\t\t\t\t// 1. Parents\n\n\t\t\t\t// Make sure that each partial will become the child of either the\n\t\t\t\t// page or another shape that exists (or that will exist) in this page.\n\n\t\t\t\tpartials = partials.map((partial) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// No parentId provided\n\t\t\t\t\t\t!partial.parentId ||\n\t\t\t\t\t\t// A parentId is proved but the parent is neither a) in the store\n\t\t\t\t\t\t// or b) among the other creating shape partials\n\t\t\t\t\t\t(!this.store.get(partial.parentId) && !partials.find((p) => p.id === partial.parentId))\n\t\t\t\t\t) {\n\t\t\t\t\t\tpartial = { ...partial }\n\t\t\t\t\t\tconst parentId = this.getParentIdForNewShapeAtPoint(\n\t\t\t\t\t\t\t{ x: partial.x ?? 0, y: partial.y ?? 0 },\n\t\t\t\t\t\t\tpartial.type\n\t\t\t\t\t\t)\n\t\t\t\t\t\tpartial.parentId = parentId\n\t\t\t\t\t\t// If the parent is a shape (rather than a page) then insert the\n\t\t\t\t\t\t// shapes into the shape's children. Ajust the point and page rotation to be\n\t\t\t\t\t\t// preserved relative to the parent.\n\t\t\t\t\t\tif (isShapeId(parentId)) {\n\t\t\t\t\t\t\tconst point = this.getPointInShapeSpace(this.getShapeById(parentId)!, {\n\t\t\t\t\t\t\t\tx: partial.x ?? 0,\n\t\t\t\t\t\t\t\ty: partial.y ?? 0,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tpartial.x = point.x\n\t\t\t\t\t\t\tpartial.y = point.y\n\t\t\t\t\t\t\tpartial.rotation = -this.getPageRotationById(parentId) + (partial.rotation ?? 0)\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn partial\n\t\t\t\t\t}\n\t\t\t\t\treturn partial\n\t\t\t\t})\n\n\t\t\t\t// 2. Indices\n\n\t\t\t\t// Get the highest index among the parents of each of the\n\t\t\t\t// the shapes being created; we'll increment from there.\n\n\t\t\t\tconst parentIndices = new Map<string, string>()\n\n\t\t\t\tconst shapeRecordsTocreate: TLShape[] = []\n\n\t\t\t\tfor (const partial of partials) {\n\t\t\t\t\tconst util = this.getShapeUtil(partial as TLShape)\n\n\t\t\t\t\t// If an index is not explicitly provided, then add the\n\t\t\t\t\t// shapes to the top of their parents' children; using the\n\t\t\t\t\t// value in parentsMappedToIndex, get the index above, use it,\n\t\t\t\t\t// and set it back to parentsMappedToIndex for next time.\n\t\t\t\t\tlet index = partial.index\n\n\t\t\t\t\tif (!index) {\n\t\t\t\t\t\tconst parentId = partial.parentId ?? focusLayerId\n\t\t\t\t\t\tif (!parentIndices.has(parentId)) {\n\t\t\t\t\t\t\tparentIndices.set(parentId, this.getHighestIndexForParent(parentId))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex = parentIndices.get(parentId)!\n\t\t\t\t\t\tparentIndices.set(parentId, getIndexAbove(index))\n\t\t\t\t\t}\n\n\t\t\t\t\t// The initial props starts as the shape utility's default props\n\t\t\t\t\tconst initialProps = util.defaultProps()\n\n\t\t\t\t\t// We then look up each key in the tab state's props; and if it's there,\n\t\t\t\t\t// we use the value from the tab state's props instead of the default.\n\t\t\t\t\t// Note that props will never include opacity.\n\t\t\t\t\tconst { propsForNextShape } = this.instanceState\n\t\t\t\t\tfor (const key in initialProps) {\n\t\t\t\t\t\tif (key in propsForNextShape) {\n\t\t\t\t\t\t\tif (key === 'url') continue\n\t\t\t\t\t\t\t;(initialProps as any)[key] = (propsForNextShape as any)[key]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// When we create the shape, take in the partial (the props coming into the\n\t\t\t\t\t// function) and merge it with the default props.\n\t\t\t\t\tlet shapeRecordToCreate = this.config.TLShape.create({\n\t\t\t\t\t\t...partial,\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\tparentId: partial.parentId ?? focusLayerId,\n\t\t\t\t\t\tprops: 'props' in partial ? { ...initialProps, ...partial.props } : initialProps,\n\t\t\t\t\t})\n\n\t\t\t\t\tif (shapeRecordToCreate.index === undefined) {\n\t\t\t\t\t\tthrow Error('no index!')\n\t\t\t\t\t}\n\n\t\t\t\t\tconst next = this.getShapeUtil(shapeRecordToCreate).onBeforeCreate?.(shapeRecordToCreate)\n\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tshapeRecordToCreate = next\n\t\t\t\t\t}\n\n\t\t\t\t\tshapeRecordsTocreate.push(shapeRecordToCreate)\n\t\t\t\t}\n\n\t\t\t\tthis.store.put(shapeRecordsTocreate)\n\n\t\t\t\t// If we're also selecting the newly created shapes, attempt to select all of them;\n\t\t\t\t// the engine will filter out any shapes that are descendants of other new shapes.\n\t\t\t\tif (select) {\n\t\t\t\t\tconst selectedIds = partials.map((partial) => partial.id)\n\t\t\t\t\tthis.store.update(this.pageState.id, (state) => ({ ...state, selectedIds }))\n\t\t\t\t}\n\t\t\t},\n\t\t\tundo: ({ partials, prevSelectedIds }) => {\n\t\t\t\tthis.store.remove(partials.map((p) => p.id))\n\n\t\t\t\tif (prevSelectedIds) {\n\t\t\t\t\tthis.store.update(this.pageState.id, (state) => ({\n\t\t\t\t\t\t...state,\n\t\t\t\t\t\tselectedIds: prevSelectedIds,\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Update shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.updateShapes([{ id: \"box1\", type: \"box\", x: 100, y: 100}])\n\t * ```\n\t *\n\t * @param partials - The shape partials to update.\n\t * @param squashing - Whether the change is ephemeral.\n\t * @public\n\t */\n\tupdateShapes = (partials: (TLShapePartial | null | undefined)[], squashing = false) => {\n\t\tif (this.animatingShapes.size > 0) {\n\t\t\tlet partial: TLShapePartial | null | undefined\n\t\t\tfor (let i = 0; i < partials.length; i++) {\n\t\t\t\tpartial = partials[i]\n\t\t\t\tif (partial) {\n\t\t\t\t\tthis.animatingShapes.delete(partial.id)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._updateShapes(partials, squashing)\n\t\treturn this\n\t}\n\n\tprivate animatingShapes = new Map<TLShapeId, string>()\n\n\t/**\n\t * Animate shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.animateShapes([{ id: \"box1\", type: \"box\", x: 100, y: 100}])\n\t * ```\n\t *\n\t * @param partials - The shape partials to update.\n\t * @public\n\t */\n\tanimateShapes = (\n\t\tpartials: (TLShapePartial | null | undefined)[],\n\t\toptions: {\n\t\t\t/** The animation's duration in milliseconds. */\n\t\t\tduration?: number\n\t\t\t/** The animation's easing function. */\n\t\t\tease?: (t: number) => number\n\t\t} = {}\n\t) => {\n\t\tconst { duration = 500, ease = EASINGS.linear } = options\n\n\t\tconst animationId = uniqueId()\n\n\t\tlet remaining = duration\n\t\tlet t: number\n\n\t\ttype FromTo = { prop: string; from: number; to: number }\n\t\ttype ShapeAnimation = { partial: TLShapePartial; values: FromTo[] }\n\n\t\tconst animations: ShapeAnimation[] = []\n\n\t\tpartials.forEach((partial) => {\n\t\t\tif (!partial) return\n\n\t\t\tconst result: ShapeAnimation = {\n\t\t\t\tpartial,\n\t\t\t\tvalues: [],\n\t\t\t}\n\n\t\t\tconst shape = this.getShapeById(partial.id)!\n\n\t\t\tif (!shape) return\n\n\t\t\tfor (const key of ['x', 'y', 'rotation'] as const) {\n\t\t\t\tif (partial[key] !== undefined && shape[key] !== partial[key]) {\n\t\t\t\t\tresult.values.push({ prop: key, from: shape[key], to: partial[key] as number })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tanimations.push(result)\n\t\t\tthis.animatingShapes.set(shape.id, animationId)\n\t\t})\n\n\t\tlet value: ShapeAnimation\n\n\t\tconst handleTick = (elapsed: number) => {\n\t\t\tremaining -= elapsed\n\n\t\t\tif (remaining < 0) {\n\t\t\t\tconst { animatingShapes } = this\n\t\t\t\tconst partialsToUpdate = partials.filter(\n\t\t\t\t\t(p) => p && animatingShapes.get(p.id) === animationId\n\t\t\t\t)\n\t\t\t\tif (partialsToUpdate.length) {\n\t\t\t\t\tthis.updateShapes(partialsToUpdate, false)\n\t\t\t\t\t// update shapes also removes the shape from animating shapes\n\t\t\t\t}\n\n\t\t\t\tthis.removeListener('tick', handleTick)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tt = ease(1 - remaining / duration)\n\n\t\t\tconst { animatingShapes } = this\n\n\t\t\ttry {\n\t\t\t\tconst tPartials: TLShapePartial[] = []\n\n\t\t\t\tfor (let i = 0; i < animations.length; i++) {\n\t\t\t\t\tvalue = animations[i]\n\n\t\t\t\t\tif (animatingShapes.get(value.partial.id) === animationId) {\n\t\t\t\t\t\ttPartials.push({\n\t\t\t\t\t\t\tid: value.partial.id,\n\t\t\t\t\t\t\ttype: value.partial.type,\n\t\t\t\t\t\t\t...value.values.reduce((acc, { prop, from, to }) => {\n\t\t\t\t\t\t\t\tacc[prop] = from + (to - from) * t\n\t\t\t\t\t\t\t\treturn acc\n\t\t\t\t\t\t\t}, {} as any),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._updateShapes(tPartials, true)\n\t\t\t} catch (e) {\n\t\t\t\t// noop\n\t\t\t}\n\t\t}\n\n\t\tthis.addListener('tick', handleTick)\n\n\t\treturn this\n\t}\n\n\tprivate _updateShapes = this.history.createCommand(\n\t\t'updateShapes',\n\t\t(_partials: (TLShapePartial | null | undefined)[], squashing = false) => {\n\t\t\tif (this.isReadOnly) return null\n\n\t\t\tconst partials = compact(_partials)\n\n\t\t\tconst snapshots = Object.fromEntries(\n\t\t\t\tcompact(partials.map(({ id }) => this.getShapeById(id))).map((shape) => {\n\t\t\t\t\treturn [shape.id, shape]\n\t\t\t\t})\n\t\t\t)\n\n\t\t\tif (partials.length <= 0) return null\n\n\t\t\tconst updated = compact(\n\t\t\t\tpartials.map((partial) => {\n\t\t\t\t\tconst prev = snapshots[partial.id]\n\t\t\t\t\tif (!prev) return null\n\t\t\t\t\tlet newRecord = null as null | TLShape\n\t\t\t\t\tfor (const [k, v] of Object.entries(partial)) {\n\t\t\t\t\t\tswitch (k) {\n\t\t\t\t\t\t\tcase 'id':\n\t\t\t\t\t\t\tcase 'type':\n\t\t\t\t\t\t\tcase 'typeName': {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\tif (v !== (prev as any)[k]) {\n\t\t\t\t\t\t\t\t\tif (!newRecord) {\n\t\t\t\t\t\t\t\t\t\tnewRecord = { ...prev }\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (k === 'props') {\n\t\t\t\t\t\t\t\t\t\tnewRecord!.props = { ...prev.props, ...(v as any) }\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t;(newRecord as any)[k] = v\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn newRecord ?? prev\n\t\t\t\t})\n\t\t\t) as TLShape[]\n\n\t\t\tconst updates = Object.fromEntries(updated.map((shape) => [shape.id, shape]))\n\n\t\t\treturn { data: { snapshots, updates }, squashing }\n\t\t},\n\t\t{\n\t\t\tdo: ({ updates }) => {\n\t\t\t\tconst arr = Object.values(updates)\n\n\t\t\t\t// Iterate through array; if any shape has an onUpdate handler, call it\n\t\t\t\t// and, if the handler returns a new shape, replace the old shape with\n\t\t\t\t// the new one. This is used for example when repositioning a text shape\n\t\t\t\t// based on its new text content.\n\t\t\t\tlet shape: TLShape\n\t\t\t\tlet next: TLShape | void\n\t\t\t\tfor (let i = 0, n = arr.length; i < n; i++) {\n\t\t\t\t\tshape = arr[i]\n\t\t\t\t\tnext = this.getShapeUtil(shape).onBeforeUpdate?.(this.store.get(shape.id)!, shape)\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\tarr[i] = next\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.store.put(arr)\n\t\t\t},\n\t\t\tundo: ({ snapshots }) => {\n\t\t\t\tthis.store.put(Object.values(snapshots))\n\t\t\t},\n\t\t\tsquash(prevData, nextData) {\n\t\t\t\treturn {\n\t\t\t\t\t// keep the oldest snapshots\n\t\t\t\t\tsnapshots: { ...nextData.snapshots, ...prevData.snapshots },\n\t\t\t\t\t// keep the newest updates\n\t\t\t\t\tupdates: { ...prevData.updates, ...nextData.updates },\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Delete shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.deleteShapes()\n\t * \tapp.deleteShapes(['box1', 'box2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to delete. Defaults to the selected shapes.\n\t * @public\n\t */\n\tdeleteShapes = (ids: TLShapeId[] = this.selectedIds) => {\n\t\tthis._deleteShapes(ids)\n\t\treturn this\n\t}\n\n\tprivate _deleteShapes = this.history.createCommand(\n\t\t'delete_shapes',\n\t\t(ids: TLShapeId[]) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (ids.length === 0) return null\n\t\t\tconst prevSelectedIds = [...this.pageState.selectedIds]\n\n\t\t\tconst allIds = new Set(ids)\n\n\t\t\tfor (const id of ids) {\n\t\t\t\tthis.visitDescendants(id, (childId) => {\n\t\t\t\t\tallIds.add(childId)\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tconst deletedIds = [...allIds]\n\t\t\tconst arrowBindings = this._arrowBindingsIndex.value\n\t\t\tconst snapshots = compact(\n\t\t\t\tdeletedIds.flatMap((id) => {\n\t\t\t\t\tconst shape = this.getShapeById(id)\n\n\t\t\t\t\t// Add any bound arrows to the snapshots, so that we can restore the bindings on undo\n\t\t\t\t\tconst bindings = arrowBindings[id]\n\t\t\t\t\tif (bindings && bindings.length > 0) {\n\t\t\t\t\t\treturn bindings.map(({ arrowId }) => this.getShapeById(arrowId)).concat(shape)\n\t\t\t\t\t}\n\t\t\t\t\treturn shape\n\t\t\t\t})\n\t\t\t)\n\n\t\t\tconst postSelectedIds = prevSelectedIds.filter((id) => !allIds.has(id))\n\n\t\t\treturn { data: { deletedIds, snapshots, prevSelectedIds, postSelectedIds } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ deletedIds, postSelectedIds }) => {\n\t\t\t\tthis.store.remove(deletedIds)\n\t\t\t\tthis.store.update(this.pageState.id, (state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tselectedIds: postSelectedIds,\n\t\t\t\t}))\n\t\t\t},\n\t\t\tundo: ({ snapshots, prevSelectedIds }) => {\n\t\t\t\tthis.store.put(snapshots)\n\t\t\t\tthis.store.update(this.pageState.id, (state) => ({\n\t\t\t\t\t...state,\n\t\t\t\t\tselectedIds: prevSelectedIds,\n\t\t\t\t}))\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Update user document settings\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.updateUserDocumentSettings({ isGridMode: true })\n\t * ```\n\t */\n\tupdateUserDocumentSettings = this.history.createCommand(\n\t\t'updateUserDocumentSettings',\n\t\t(partial: Partial<TLUserDocument>, ephemeral = false) => {\n\t\t\t// Should we prevent a user from changing isReadOnly?\n\t\t\tconst prev = this.userDocumentSettings\n\t\t\tconst next = { ...prev, ...partial }\n\t\t\treturn { data: { prev, next }, ephemeral }\n\t\t},\n\t\t{\n\t\t\tdo: ({ next }) => {\n\t\t\t\tthis.store.put([next])\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.put([prev])\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Update a page.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.updatePage({ id: 'page2', name: 'Page 2' })\n\t * ```\n\t *\n\t * @param partial - The partial of the shape to update.\n\t * @public\n\t */\n\tupdatePage = this.history.createCommand(\n\t\t'updatePage',\n\t\t(partial: RequiredKeys<TLPage, 'id'>, squashing = false) => {\n\t\t\tif (this.isReadOnly) return null\n\n\t\t\tconst prev = this.getPageById(partial.id)\n\n\t\t\tif (!prev) return null\n\n\t\t\treturn { data: { prev, partial }, squashing }\n\t\t},\n\t\t{\n\t\t\tdo: ({ partial }) => {\n\t\t\t\tthis.store.update(partial.id, (page) => ({ ...page, ...partial }))\n\t\t\t},\n\t\t\tundo: ({ prev, partial }) => {\n\t\t\t\tthis.store.update(partial.id, () => prev)\n\t\t\t},\n\t\t\tsquash(prevData, nextData) {\n\t\t\t\treturn {\n\t\t\t\t\tprev: { ...prevData.prev, ...nextData.prev },\n\t\t\t\t\tpartial: nextData.partial,\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Create a page.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.createPage('New Page')\n\t * \tapp.createPage('New Page', 'page1')\n\t * ```\n\t *\n\t * @param id - The new page's id.\n\t * @param title - The new page's title.\n\t * @public\n\t */\n\tcreatePage = this.history.createCommand(\n\t\t'createPage',\n\t\t(title: string, id: TLPageId = TLPage.createId(), belowPageIndex?: string) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (this.pages.length >= MAX_PAGES) return null\n\t\t\tconst pageInfo = this.pages\n\t\t\tconst topIndex = belowPageIndex ?? pageInfo[pageInfo.length - 1]?.index ?? 'a1'\n\t\t\tconst bottomIndex = pageInfo[pageInfo.findIndex((p) => p.index === topIndex) + 1]?.index\n\n\t\t\tconst prevPageState = { ...this.pageState }\n\t\t\tconst prevInstanceState = { ...this.instanceState }\n\n\t\t\ttitle = getIncrementedName(\n\t\t\t\ttitle,\n\t\t\t\tpageInfo.map((p) => p.name)\n\t\t\t)\n\n\t\t\tconst newPage = TLPage.create({\n\t\t\t\tid,\n\t\t\t\tname: title,\n\t\t\t\tindex: bottomIndex ? getIndexBetween(topIndex, bottomIndex) : getIndexAbove(topIndex),\n\t\t\t})\n\n\t\t\tconst newCamera = TLCamera.create({})\n\n\t\t\tconst newTabPageState = TLInstancePageState.create({\n\t\t\t\tpageId: newPage.id,\n\t\t\t\tinstanceId: this.instanceId,\n\t\t\t\tcameraId: newCamera.id,\n\t\t\t})\n\n\t\t\treturn {\n\t\t\t\tdata: {\n\t\t\t\t\tprevPageState,\n\t\t\t\t\tprevTabState: prevInstanceState,\n\t\t\t\t\tnewPage,\n\t\t\t\t\tnewTabPageState,\n\t\t\t\t\tnewCamera,\n\t\t\t\t},\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ newPage, newTabPageState, newCamera }) => {\n\t\t\t\tthis.store.put([\n\t\t\t\t\tnewPage,\n\t\t\t\t\tnewCamera,\n\t\t\t\t\tnewTabPageState,\n\t\t\t\t\t{ ...this.instanceState, currentPageId: newPage.id },\n\t\t\t\t])\n\t\t\t\tthis.updateCullingViewport()\n\t\t\t},\n\t\t\tundo: ({ newPage, prevPageState, prevTabState, newTabPageState }) => {\n\t\t\t\tthis.store.put([prevPageState, prevTabState])\n\t\t\t\tthis.store.remove([newTabPageState.id, newPage.id, newTabPageState.cameraId])\n\t\t\t\tthis.updateCullingViewport()\n\t\t\t},\n\t\t}\n\t)\n\n\tduplicatePage = (id: TLPageId = this.currentPageId, createId: TLPageId = TLPage.createId()) => {\n\t\tif (this.pages.length >= MAX_PAGES) return\n\t\tconst page = this.getPageById(id)\n\t\tif (!page) return\n\n\t\tconst camera = { ...this.camera }\n\t\tconst content = this.getContent(this.getSortedChildren(page.id))\n\n\t\tthis.batch(() => {\n\t\t\tthis.createPage(page.name + ' Copy', createId, page.index)\n\t\t\tthis.setCurrentPage(createId)\n\t\t\tthis.setCamera(camera.x, camera.y, camera.z)\n\n\t\t\t// will change page automatically\n\t\t\tif (content) {\n\t\t\t\treturn this.putContent(content)\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Delete a page.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.deletePage('page1')\n\t * ```\n\t *\n\t * @param id - The id of the page to delete.\n\t * @public\n\t */\n\tdeletePage = this.history.createCommand(\n\t\t'delete_page',\n\t\t(id: TLPageId) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tconst { pages } = this\n\t\t\tif (pages.length === 1) return null\n\n\t\t\tconst deletedPage = this.getPageById(id)\n\t\t\tconst deletedPageStates = this._pageStates.value.filter((s) => s.pageId === id)\n\n\t\t\tif (!deletedPage) return null\n\n\t\t\tif (id === this.currentPageId) {\n\t\t\t\tconst index = pages.findIndex((page) => page.id === id)\n\t\t\t\tconst next = pages[index - 1] ?? pages[index + 1]\n\t\t\t\tthis.setCurrentPage(next.id)\n\t\t\t}\n\n\t\t\treturn { data: { id, deletedPage, deletedPageStates } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ deletedPage, deletedPageStates }) => {\n\t\t\t\tthis.store.remove(deletedPageStates.map((s) => s.id)) // remove the page state\n\t\t\t\tthis.store.remove([deletedPage.id]) // remove the page\n\t\t\t\tthis.updateCullingViewport()\n\t\t\t},\n\t\t\tundo: ({ deletedPage, deletedPageStates }) => {\n\t\t\t\tthis.store.put([deletedPage])\n\t\t\t\tthis.store.put(deletedPageStates)\n\t\t\t\tthis.updateCullingViewport()\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Update a page state.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setPageState({ id: 'page1' })\n\t * \tapp.setPageState({ id: 'page1' }, true)\n\t * ```\n\t *\n\t * @param partial - The partial of the page state object containing the changes.\n\t * @param ephemeral - Whether the command is ephemeral.\n\t * @public\n\t */\n\tsetPageState = this.history.createCommand(\n\t\t'setPageState',\n\t\t(partial: Partial<TLInstancePageState>, ephemeral = false) => {\n\t\t\tconst prev = this.store.get(partial.id ?? this.pageState.id)!\n\t\t\treturn { data: { prev, partial }, ephemeral }\n\t\t},\n\t\t{\n\t\t\tdo: ({ prev, partial }) => {\n\t\t\t\tthis.store.update(prev.id, (state) => ({ ...state, ...partial }))\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.update(prev.id, () => prev)\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Set user state. Always ephemeral for now.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.updateUser({ color: '#923433' })\n\t * ```\n\t *\n\t * @param partial - The partial of the user state object containing the changes.\n\t * @public\n\t */\n\tupdateUser = (partial: Partial<TLUser>) => {\n\t\tconst next = { ...this.user, ...partial }\n\t\tthis.store.put([next])\n\t}\n\n\t@computed private get _currentUserPresence() {\n\t\treturn this.store.query.record('user_presence', () => ({ userId: { eq: this.userId } }))\n\t}\n\n\tget userPresence() {\n\t\treturn this._currentUserPresence.value\n\t}\n\n\t// when a user performs any action in the app, we update their presence record\n\tupdateUserPresence = ({ cursor, color }: { cursor?: Vec2dModel; color?: string } = {}) => {\n\t\tconst presence = this._currentUserPresence.value\n\t\tif (!presence) {\n\t\t\tconsole.error('No presence found for current user')\n\t\t\treturn\n\t\t}\n\n\t\tthis.store.put([\n\t\t\t{\n\t\t\t\t...presence,\n\t\t\t\tcursor: cursor ?? presence.cursor,\n\t\t\t\tcolor: color ?? presence.color,\n\t\t\t\tlastUsedInstanceId: this.instanceId,\n\t\t\t\tlastActivityTimestamp: Date.now(),\n\t\t\t},\n\t\t])\n\t}\n\n\t/**\n\t * Select one or more shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setSelectedIds(['id1'])\n\t * \tapp.setSelectedIds(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids to select.\n\t * @param squashing - Whether the change should create a new history entry or combine with the\n\t *   previous (if the previous is the same type).\n\t * @public\n\t */\n\tsetSelectedIds = this.history.createCommand(\n\t\t'setSelectedIds',\n\t\t(ids: TLShapeId[], squashing = false) => {\n\t\t\tconst prevSelectedIds = this.pageState.selectedIds\n\n\t\t\tconst prevSet = new Set(this.pageState.selectedIds)\n\n\t\t\tif (ids.length === prevSet.size && ids.every((id) => prevSet.has(id))) return null\n\n\t\t\treturn { data: { ids, prevSelectedIds }, squashing, preservesRedoStack: true }\n\t\t},\n\t\t{\n\t\t\tdo: ({ ids }) => {\n\t\t\t\tthis.store.update(this.pageState.id, (state) => ({ ...state, selectedIds: ids }))\n\t\t\t},\n\t\t\tundo: ({ prevSelectedIds }) => {\n\t\t\t\tthis.store.update(this.pageState.id, () => ({\n\t\t\t\t\t...this.pageState,\n\t\t\t\t\tselectedIds: prevSelectedIds,\n\t\t\t\t}))\n\t\t\t},\n\t\t\tsquash(prev, next) {\n\t\t\t\treturn { ids: next.ids, prevSelectedIds: prev.prevSelectedIds }\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Determine whether or not a shape is selected\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.isSelected('id1')\n\t * ```\n\t *\n\t * @param id - The id of the shape to check.\n\t * @public\n\t */\n\tisSelected = (id: TLShapeId) => this.selectedIdsSet.has(id)\n\n\t/**\n\t * Determine whether a not a shape is within the current selection. A shape\n\t * is within the selection if it or any of its parents is selected.\n\t *\n\t * @param id - The id of the shape to check.\n\t * @public\n\t */\n\tisWithinSelection = (id: TLShapeId) => {\n\t\tconst shape = this.getShapeById(id)\n\t\tif (!shape) return false\n\n\t\tif (this.isSelected(id)) return true\n\n\t\treturn !!this.findAncestor(shape, (parent) => this.isSelected(parent.id))\n\t}\n\n\t/* --------------------- Assets --------------------- */\n\n\t@computed private get _assets() {\n\t\treturn this.store.query.records('asset')\n\t}\n\n\t/**\n\t * Get all assets in the app.\n\t */\n\tget assets() {\n\t\treturn this._assets.value\n\t}\n\n\t/**\n\t * Create one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.createAssets([...myAssets])\n\t * ```\n\t *\n\t * @param assets - The assets to create.\n\t * @public\n\t */\n\tcreateAssets = this.history.createCommand(\n\t\t'createAssets',\n\t\t(assets: TLAsset[]) => {\n\t\t\tif (this.isReadOnly) return null\n\t\t\tif (assets.length <= 0) return null\n\n\t\t\treturn { data: { assets } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ assets }) => {\n\t\t\t\tthis.store.put(assets)\n\t\t\t},\n\t\t\tundo: ({ assets }) => {\n\t\t\t\tthis.store.remove(assets.map((a) => a.id))\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Delete one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.deleteAssets(['asset1', 'asset2'])\n\t * ```\n\t *\n\t * @param ids - The assets to delete.\n\t * @public\n\t */\n\tdeleteAssets = this.history.createCommand(\n\t\t'deleteAssets',\n\t\t(ids: TLAssetId[]) => {\n\t\t\tif (this.isReadOnly) return\n\t\t\tif (ids.length <= 0) return\n\n\t\t\tconst prev = compact(ids.map((id) => this.store.get(id)))\n\n\t\t\treturn { data: { ids, prev } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ ids }) => {\n\t\t\t\tthis.store.remove(ids)\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.put(prev)\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Update one or more assets.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.updateAssets([{ id: 'asset1', name: 'New name' }])\n\t * ```\n\t *\n\t * @param assets - The assets to update.\n\t * @public\n\t */\n\tupdateAssets = this.history.createCommand(\n\t\t'updateAssets',\n\t\t(assets: TLAssetPartial[]) => {\n\t\t\tif (this.isReadOnly) return\n\t\t\tif (assets.length <= 0) return\n\n\t\t\tconst snapshots: Record<string, TLAsset> = {}\n\n\t\t\treturn { data: { snapshots, assets } }\n\t\t},\n\t\t{\n\t\t\tdo: ({ assets, snapshots }) => {\n\t\t\t\tthis.store.put(\n\t\t\t\t\tassets.map((a) => {\n\t\t\t\t\t\tconst asset = this.store.get(a.id)!\n\t\t\t\t\t\tsnapshots[a.id] = asset\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t...asset,\n\t\t\t\t\t\t\t...a,\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t},\n\t\t\tundo: ({ snapshots }) => {\n\t\t\t\tthis.store.put(Object.values(snapshots))\n\t\t\t},\n\t\t}\n\t)\n\n\t/**\n\t * Get an asset by its src property.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getAssetBySource('https://example.com/image.png')\n\t * ```\n\t *\n\t * @param src - The source value of the asset.\n\t * @public\n\t */\n\tgetAssetBySrc = (src: string) => {\n\t\treturn this.assets.find((a) => a.props.src === src)\n\t}\n\n\t/**\n\t * Get an asset by its id.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.getAssetById('asset1')\n\t * ```\n\t *\n\t * @param id - The id of the asset.\n\t * @public\n\t */\n\tgetAssetById = (id: TLAssetId): TLAsset | undefined => {\n\t\treturn this.store.get(id) as TLAsset | undefined\n\t}\n\n\t/* ------------------- SubCommands ------------------ */\n\tgetSvg = async (\n\t\tids: TLShapeId[] = (this.selectedIds.length\n\t\t\t? this.selectedIds\n\t\t\t: Object.keys(this.shapeIds)) as TLShapeId[],\n\t\topts = {} as Partial<{\n\t\t\tscale: number\n\t\t\tbackground: boolean\n\t\t\tpadding: number\n\t\t\tdarkMode?: boolean\n\t\t\tpreserveAspectRatio: React.SVGAttributes<SVGSVGElement>['preserveAspectRatio']\n\t\t}>\n\t) => {\n\t\tif (ids.length === 0) return\n\t\tif (!window.document) throw Error('No document')\n\n\t\tconst {\n\t\t\tscale = 1,\n\t\t\tbackground = false,\n\t\t\tpadding = SVG_PADDING,\n\t\t\tdarkMode = this.userDocumentSettings.isDarkMode,\n\t\t\tpreserveAspectRatio = false,\n\t\t} = opts\n\n\t\tconst realContainerEl = this.getContainer()\n\t\tconst realContainerStyle = getComputedStyle(realContainerEl)\n\n\t\t// Get the styles from the container. We'll use these to pull out colors etc.\n\t\t// NOTE: We can force force a light theme here becasue we don't want export\n\t\tconst fakeContainerEl = document.createElement('div')\n\t\tfakeContainerEl.className = `rs-container rs-theme__${darkMode ? 'dark' : 'light'}`\n\t\tdocument.body.appendChild(fakeContainerEl)\n\n\t\tconst containerStyle = getComputedStyle(fakeContainerEl)\n\t\tconst fontsUsedInExport = new Map<string, string>()\n\n\t\tconst colors: TLExportColors = {\n\t\t\tfill: Object.fromEntries(\n\t\t\t\tSTYLES.color.map((color) => [\n\t\t\t\t\tcolor.id,\n\t\t\t\t\tcontainerStyle.getPropertyValue(`--palette-${color.id}`),\n\t\t\t\t])\n\t\t\t) as Record<TLColorType, string>,\n\t\t\tpattern: Object.fromEntries(\n\t\t\t\tSTYLES.color.map((color) => [\n\t\t\t\t\tcolor.id,\n\t\t\t\t\tcontainerStyle.getPropertyValue(`--palette-${color.id}-pattern`),\n\t\t\t\t])\n\t\t\t) as Record<TLColorType, string>,\n\t\t\tsemi: Object.fromEntries(\n\t\t\t\tSTYLES.color.map((color) => [\n\t\t\t\t\tcolor.id,\n\t\t\t\t\tcontainerStyle.getPropertyValue(`--palette-${color.id}-semi`),\n\t\t\t\t])\n\t\t\t) as Record<TLColorType, string>,\n\t\t\ttext: containerStyle.getPropertyValue(`--color-text`),\n\t\t\tbackground: containerStyle.getPropertyValue(`--color-background`),\n\t\t\tsolid: containerStyle.getPropertyValue(`--palette-solid`),\n\t\t}\n\n\t\t// Remove containerEl from DOM (temp DOM node)\n\t\tdocument.body.removeChild(fakeContainerEl)\n\n\t\t// ---Figure out which shapes we need to include\n\n\t\tconst shapes = this.getShapesAndDescendantsInOrder(ids)\n\n\t\t// --- Common bounding box of all shapes\n\n\t\t// Get the common bounding box for the selected nodes (with some padding)\n\t\tconst bbox = Box2d.FromPoints(\n\t\t\tshapes\n\t\t\t\t.map((shape) => {\n\t\t\t\t\tconst pageTransform = this.getPageTransform(shape)!\n\t\t\t\t\tconst pageOutline = Matrix2d.applyToPoints(pageTransform, this.getOutline(shape))\n\t\t\t\t\treturn pageOutline\n\t\t\t\t})\n\t\t\t\t.flat()\n\t\t)\n\n\t\t// Expand by an extra 32 pixels\n\t\tbbox.expandBy(padding)\n\n\t\t// --- Create the SVG\n\n\t\t// Embed our custom fonts\n\t\tconst svg = window.document.createElementNS('http://www.w3.org/2000/svg', 'svg')\n\n\t\tif (preserveAspectRatio) {\n\t\t\tsvg.setAttribute('preserveAspectRatio', preserveAspectRatio)\n\t\t}\n\n\t\t// Use the bounding box to set the size and viewBox of the svg\n\n\t\t// We want the svg image to be BIGGER THAN USUAL to account for image quality\n\t\tconst w = bbox.width * scale\n\t\tconst h = bbox.height * scale\n\n\t\tsvg.setAttribute('direction', 'ltr')\n\t\tsvg.setAttribute('width', w + '')\n\t\tsvg.setAttribute('height', h + '')\n\t\tsvg.setAttribute('viewBox', `${bbox.minX} ${bbox.minY} ${bbox.width} ${bbox.height}`)\n\t\tsvg.setAttribute('stroke-linecap', 'round')\n\t\tsvg.setAttribute('stroke-linejoin', 'round')\n\t\t// Add current background color, or else background will be transparent\n\t\tsvg.style.setProperty('background-color', background ? colors.background : 'transparent')\n\n\t\t// Add the defs to the svg\n\t\tconst defs = window.document.createElementNS('http://www.w3.org/2000/svg', 'defs')\n\n\t\tfor (const element of Array.from(exportPatternSvgDefs())) {\n\t\t\tdefs.appendChild(element)\n\t\t}\n\n\t\ttry {\n\t\t\tdocument.body.focus?.() // weird but necessary\n\t\t} catch (e) {\n\t\t\t// not implemented\n\t\t}\n\n\t\tsvg.append(defs)\n\n\t\t// Must happen in order, not using a promise.all, or else the order of the\n\t\t// elements in the svg will be wrong.\n\n\t\tfor (const shape of shapes) {\n\t\t\tlet font: string | undefined\n\n\t\t\tif ('font' in shape.props) {\n\t\t\t\tif (shape.props.font) {\n\t\t\t\t\tif (fontsUsedInExport.has(shape.props.font)) {\n\t\t\t\t\t\tfont = fontsUsedInExport.get(shape.props.font)!\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// For some reason these styles aren't present in the fake element\n\t\t\t\t\t\t// so we need to get them from the real element\n\t\t\t\t\t\tfont = realContainerStyle.getPropertyValue(`--rs-font-${shape.props.font}`)\n\t\t\t\t\t\tfontsUsedInExport.set(shape.props.font, font)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst util = this.getShapeUtil(shape)\n\n\t\t\tlet utilSvgElement = await util.toSvg?.(shape, font, colors)\n\n\t\t\tif (!utilSvgElement) {\n\t\t\t\tconst bounds = this.getPageBounds(shape)!\n\t\t\t\tconst elm = window.document.createElementNS('http://www.w3.org/2000/svg', 'rect')\n\t\t\t\telm.setAttribute('width', bounds.width + '')\n\t\t\t\telm.setAttribute('height', bounds.height + '')\n\t\t\t\telm.setAttribute('fill', colors.solid)\n\t\t\t\telm.setAttribute('stroke', colors.pattern.grey)\n\t\t\t\telm.setAttribute('stroke-width', '1')\n\t\t\t\tutilSvgElement = elm\n\t\t\t}\n\n\t\t\t// If the node implements toSvg, use that\n\t\t\tconst shapeSvg = utilSvgElement\n\n\t\t\tlet pageTransform = this.getPageTransform(shape)!.toCssString()\n\n\t\t\tif ('scale' in shape.props) {\n\t\t\t\tif (shape.props.scale !== 1) {\n\t\t\t\t\tpageTransform = `${pageTransform} scale(${shape.props.scale}, ${shape.props.scale})`\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tshapeSvg.setAttribute('transform', pageTransform)\n\t\t\tif ('opacity' in shape.props) shapeSvg.setAttribute('opacity', shape.props.opacity + '')\n\n\t\t\t// Append it to the SVG\n\t\t\tsvg.appendChild(shapeSvg)\n\n\t\t\t// Create svg mask if shape has a frame as parent\n\t\t\tconst clipPath = this._clipPathCache.get(shape.id)\n\t\t\tif (shapeSvg && clipPath) {\n\t\t\t\t// Safari doesn't rotate clip-path's unless they are nested within an element\n\t\t\t\t// See <https://linear.app/tldraw/issue/TLD-1011/svg-export-gets-clipped-in-safari>\n\t\t\t\tconst innerElement = document.createElementNS('http://www.w3.org/2000/svg', 'g')\n\t\t\t\tinnerElement.style.clipPath = clipPath\n\t\t\t\tconst nodes = Array.from(shapeSvg.childNodes)\n\t\t\t\tnodes.forEach((node) => innerElement.appendChild(node))\n\t\t\t\tshapeSvg.appendChild(innerElement)\n\t\t\t}\n\t\t}\n\n\t\t// Add styles to the defs\n\n\t\tlet styles = ``\n\t\tconst style = window.document.createElementNS('http://www.w3.org/2000/svg', 'style')\n\n\t\t// Insert fonts into app\n\t\tconst fontInstances: any[] = []\n\n\t\tif ('fonts' in document) {\n\t\t\tdocument.fonts.forEach((font) => fontInstances.push(font))\n\t\t}\n\n\t\tfor (const font of fontInstances) {\n\t\t\tconst fileReader = new FileReader()\n\n\t\t\tlet isUsed = false\n\n\t\t\tfontsUsedInExport.forEach((fontName) => {\n\t\t\t\tif (fontName.includes(font.family)) {\n\t\t\t\t\tisUsed = true\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif (!isUsed) continue\n\n\t\t\tconst url = (font as any).$$_url\n\n\t\t\tconst fontFaceRule = (font as any).$$_fontface\n\n\t\t\tif (url) {\n\t\t\t\tconst fontFile = await (await fetch(url)).blob()\n\n\t\t\t\tconst base64Font = await new Promise<string>((resolve, reject) => {\n\t\t\t\t\tfileReader.onload = () => resolve(fileReader.result as string)\n\t\t\t\t\tfileReader.onerror = () => reject(fileReader.error)\n\t\t\t\t\tfileReader.readAsDataURL(fontFile)\n\t\t\t\t})\n\n\t\t\t\tconst newFontFaceRule = '\\n' + fontFaceRule.replaceAll(url, base64Font)\n\t\t\t\tstyles += newFontFaceRule\n\t\t\t}\n\t\t}\n\n\t\tstyle.textContent = styles\n\n\t\tdefs.append(style)\n\n\t\treturn svg\n\t}\n\n\t/**\n\t * Rename a page.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.renamePage('page1', 'My Page')\n\t * ```\n\t *\n\t * @param id - The id of the page to rename.\n\t * @param name - The new name.\n\t * @public\n\t */\n\trenamePage = (id: TLPageId, name: string, squashing = false) => {\n\t\tif (this.isReadOnly) return this\n\t\tthis.updatePage({ id, name }, squashing)\n\t\treturn this\n\t}\n\n\t/**\n\t * Move shapes to page.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.moveShapesToPage(['box1', 'box2'], 'page1')\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move.\n\t * @param pageId - The id of the page where the shapes will be moved.\n\t * @public\n\t */\n\tmoveShapesToPage = (ids: TLShapeId[], pageId: TLPageId) => {\n\t\tif (ids.length === 0) return this\n\t\tif (this.isReadOnly) return this\n\n\t\tconst { currentPageId } = this\n\n\t\tif (pageId === currentPageId) return this\n\t\tif (!this.store.has(pageId)) return this\n\n\t\t// Basically copy the shapes\n\t\tconst content = this.getContent(ids)\n\n\t\t// Just to be sure\n\t\tif (!content) return\n\n\t\t// If there is no space on pageId, or if the selected shapes\n\t\t// would take the new page above the limit, don't move the shapes\n\t\tif (this.getShapesInPage(pageId).length + content.shapes.length > MAX_SHAPES_PER_PAGE) {\n\t\t\talertMaxShapes(this, pageId)\n\t\t\treturn\n\t\t}\n\n\t\tconst fromPageZ = this.camera.z\n\n\t\tthis.history.batch(() => {\n\t\t\t// Delete the shapes on the current page\n\t\t\tthis.deleteShapes(ids)\n\n\t\t\t// Move to the next page\n\t\t\tthis.setCurrentPage(pageId)\n\n\t\t\t// Put the shape content onto the new page; parents and indices will\n\t\t\t// be taken care of by the putContent method; make sure to pop any focus\n\t\t\t// layers so that the content will be put onto the page.\n\t\t\tthis.setFocusLayer(null)\n\t\t\tthis.selectNone()\n\t\t\tthis.putContent(content, { select: true, preserveIds: true, preservePosition: true })\n\n\t\t\t// If the new shapes are not in the viewport, force the new page's\n\t\t\t// camera to be at the same zoom level as the current page's camera,\n\t\t\t// then center it on the pasted shapes\n\t\t\tif (!this.viewport.includes(this.selectionBounds!)) {\n\t\t\t\tconst {\n\t\t\t\t\tcenter: { x, y },\n\t\t\t\t} = this.selectionBounds!\n\t\t\t\tthis.setCamera(this.camera.x, this.camera.y, fromPageZ)\n\t\t\t\tthis.centerOnPoint(x, y)\n\t\t\t}\n\t\t})\n\n\t\tthis.emit('moved-to-page', { name: this.currentPage.name, toId: pageId, fromId: currentPageId })\n\n\t\treturn this\n\t}\n\n\tlockShapes = (_ids: TLShapeId[] = this.pageState.selectedIds) => {\n\t\tif (this.isReadOnly) return this\n\t\t// todo\n\t}\n\n\t/**\n\t * Reorder shapes.\n\t *\n\t * @param operation - The operation to perform.\n\t * @param ids - The ids to reorder.\n\t * @public\n\t */\n\treorderShapes = (operation: TLReorderOperation, ids: TLShapeId[]) => {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length === 0) return this\n\n\t\tconst parents = this.getParentsMappedToChildren(ids)\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tswitch (operation) {\n\t\t\tcase 'toBack': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(this.getSortedChildren(parentId).map(this.getShapeById))\n\n\t\t\t\t\tif (movingSet.size === siblings.length) return\n\n\t\t\t\t\tlet below: string | undefined\n\t\t\t\t\tlet above: string | undefined\n\n\t\t\t\t\tfor (const shape of siblings) {\n\t\t\t\t\t\tif (!movingSet.has(shape)) {\n\t\t\t\t\t\t\tabove = shape.index\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmovingSet.delete(shape)\n\t\t\t\t\t\tbelow = shape.index\n\t\t\t\t\t}\n\n\t\t\t\t\tif (movingSet.size === 0) return\n\n\t\t\t\t\tconst indices = getIndicesBetween(below, above, movingSet.size)\n\n\t\t\t\t\tArray.from(movingSet.values())\n\t\t\t\t\t\t.sort(sortByIndex)\n\t\t\t\t\t\t.forEach((node, i) =>\n\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[i] })\n\t\t\t\t\t\t)\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'toFront': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(this.getSortedChildren(parentId).map(this.getShapeById))\n\t\t\t\t\tconst len = siblings.length\n\n\t\t\t\t\tif (movingSet.size === len) return\n\n\t\t\t\t\tlet below: string | undefined\n\t\t\t\t\tlet above: string | undefined\n\n\t\t\t\t\tfor (let i = len - 1; i > -1; i--) {\n\t\t\t\t\t\tconst shape = siblings[i]\n\n\t\t\t\t\t\tif (!movingSet.has(shape)) {\n\t\t\t\t\t\t\tbelow = shape.index\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmovingSet.delete(shape)\n\t\t\t\t\t\tabove = shape.index\n\t\t\t\t\t}\n\n\t\t\t\t\tif (movingSet.size === 0) return\n\n\t\t\t\t\tconst indices = getIndicesBetween(below, above, movingSet.size)\n\n\t\t\t\t\tArray.from(movingSet.values())\n\t\t\t\t\t\t.sort(sortByIndex)\n\t\t\t\t\t\t.forEach((node, i) =>\n\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[i] })\n\t\t\t\t\t\t)\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'forward': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(this.getSortedChildren(parentId).map(this.getShapeById))\n\t\t\t\t\tconst len = siblings.length\n\n\t\t\t\t\tif (movingSet.size === len) return\n\n\t\t\t\t\tconst movingIndices = new Set(Array.from(movingSet).map((n) => siblings.indexOf(n)))\n\n\t\t\t\t\tlet selectIndex = -1\n\t\t\t\t\tlet isSelecting = false\n\t\t\t\t\tlet below: string | undefined\n\t\t\t\t\tlet above: string | undefined\n\t\t\t\t\tlet count: number\n\n\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\tconst isMoving = movingIndices.has(i)\n\n\t\t\t\t\t\tif (!isSelecting && isMoving) {\n\t\t\t\t\t\t\tisSelecting = true\n\t\t\t\t\t\t\tselectIndex = i\n\t\t\t\t\t\t\tabove = undefined\n\t\t\t\t\t\t} else if (isSelecting && !isMoving) {\n\t\t\t\t\t\t\tisSelecting = false\n\t\t\t\t\t\t\tcount = i - selectIndex\n\t\t\t\t\t\t\tbelow = siblings[i].index\n\t\t\t\t\t\t\tabove = siblings[i + 1]?.index\n\n\t\t\t\t\t\t\tconst indices = getIndicesBetween(below, above, count)\n\n\t\t\t\t\t\t\tfor (let k = 0; k < count; k++) {\n\t\t\t\t\t\t\t\tconst node = siblings[selectIndex + k]\n\t\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[k] })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'backward': {\n\t\t\t\tparents.forEach((movingSet, parentId) => {\n\t\t\t\t\tconst siblings = compact(this.getSortedChildren(parentId).map(this.getShapeById))\n\t\t\t\t\tconst len = siblings.length\n\n\t\t\t\t\tif (movingSet.size === len) return\n\n\t\t\t\t\tconst movingIndices = new Set(Array.from(movingSet).map((n) => siblings.indexOf(n)))\n\n\t\t\t\t\tlet selectIndex = -1\n\t\t\t\t\tlet isSelecting = false\n\t\t\t\t\tlet count: number\n\n\t\t\t\t\tfor (let i = len - 1; i > -1; i--) {\n\t\t\t\t\t\tconst isMoving = movingIndices.has(i)\n\n\t\t\t\t\t\tif (!isSelecting && isMoving) {\n\t\t\t\t\t\t\tisSelecting = true\n\t\t\t\t\t\t\tselectIndex = i\n\t\t\t\t\t\t} else if (isSelecting && !isMoving) {\n\t\t\t\t\t\t\tisSelecting = false\n\t\t\t\t\t\t\tcount = selectIndex - i\n\n\t\t\t\t\t\t\tconst indices = getIndicesBetween(siblings[i - 1]?.index, siblings[i].index, count)\n\n\t\t\t\t\t\t\tfor (let k = 0; k < count; k++) {\n\t\t\t\t\t\t\t\tconst node = siblings[i + k + 1]\n\t\t\t\t\t\t\t\tchanges.push({ id: node.id as any, type: node.type, index: indices[k] })\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Send shapes to the back of the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.sendToBack()\n\t * \tapp.sendToBack(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected\n\t *   shapes.\n\t * @public\n\t */\n\tsendToBack = (ids = this.pageState.selectedIds) => {\n\t\tthis.reorderShapes('toBack', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Send shapes backward in the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.sendBackward()\n\t * \tapp.sendBackward(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected\n\t *   shapes.\n\t * @public\n\t */\n\tsendBackward = (ids = this.pageState.selectedIds) => {\n\t\tthis.reorderShapes('backward', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Bring shapes forward in the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.bringForward()\n\t * \tapp.bringForward(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected\n\t *   shapes.\n\t * @public\n\t */\n\tbringForward = (ids = this.pageState.selectedIds) => {\n\t\tthis.reorderShapes('forward', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Bring shapes to the front of the page's object list.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.bringToFront()\n\t * \tapp.bringToFront(['id1', 'id2'])\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move. Defaults to the ids of the selected\n\t *   shapes.\n\t * @public\n\t */\n\tbringToFront = (ids = this.pageState.selectedIds) => {\n\t\tthis.reorderShapes('toFront', ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Flip shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.flipShapes('horizontal')\n\t * \tapp.flipShapes('horizontal', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - Whether to flip horizontally or vertically.\n\t * @param ids - The ids of the shapes to flip. Defaults to selected shapes.\n\t * @public\n\t */\n\tflipShapes = (operation: 'horizontal' | 'vertical', ids: TLShapeId[] = this.selectedIds) => {\n\t\tif (this.isReadOnly) return this\n\n\t\tlet shapes = compact(ids.map(this.getShapeById))\n\n\t\tif (!shapes.length) return this\n\n\t\tshapes = shapes\n\t\t\t.map((shape) => {\n\t\t\t\tif (shape.type === 'group') {\n\t\t\t\t\treturn this.getSortedChildren(shape.id).map(this.getShapeById)\n\t\t\t\t}\n\n\t\t\t\treturn shape\n\t\t\t})\n\t\t\t.flat() as TLShape[]\n\n\t\tconst scaleOriginPage = Box2d.Common(compact(shapes.map(this.getPageBounds))).center\n\n\t\tfor (const shape of shapes) {\n\t\t\tconst util = this.getShapeUtil(shape)\n\t\t\tconst bounds = util.bounds(shape)\n\t\t\tconst initialPageTransform = this.getPageTransformById(shape.id)\n\t\t\tif (!initialPageTransform) continue\n\t\t\tthis.resizeShape(\n\t\t\t\tshape.id,\n\t\t\t\t{ x: operation === 'horizontal' ? -1 : 1, y: operation === 'vertical' ? -1 : 1 },\n\t\t\t\t{\n\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\tinitialPageTransform,\n\t\t\t\t\tinitialShape: shape,\n\t\t\t\t\tmode: 'scale_shape',\n\t\t\t\t\tscaleOrigin: scaleOriginPage,\n\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t}\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stack shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.stackShapes('horizontal')\n\t * \tapp.stackShapes('horizontal', ['box1', 'box2'])\n\t * \tapp.stackShapes('horizontal', ['box1', 'box2'], 20)\n\t * ```\n\t *\n\t * @param operation - Whether to stack horizontally or vertically.\n\t * @param ids - The ids of the shapes to stack. Defaults to selected shapes.\n\t * @param gap - A specific gap to use when stacking.\n\t * @public\n\t */\n\tstackShapes = (\n\t\toperation: 'horizontal' | 'vertical',\n\t\tids: TLShapeId[] = this.pageState.selectedIds,\n\t\tgap?: number\n\t) => {\n\t\tif (this.isReadOnly) return this\n\n\t\tconst shapes = compact(ids.map(this.getShapeById)).filter((shape) => {\n\t\t\tif (!shape) return false\n\n\t\t\tif (TLArrowShapeDef.is(shape)) {\n\t\t\t\tif (shape.props.start.type === 'binding' || shape.props.end.type === 'binding') {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true\n\t\t})\n\n\t\tconst len = shapes.length\n\n\t\tif ((gap === undefined && len < 3) || len < 2) return this\n\n\t\tconst pageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)!])\n\t\t)\n\n\t\tlet val: 'x' | 'y'\n\t\tlet min: 'minX' | 'minY'\n\t\tlet max: 'maxX' | 'maxY'\n\t\tlet dim: 'width' | 'height'\n\n\t\tif (operation === 'horizontal') {\n\t\t\tval = 'x'\n\t\t\tmin = 'minX'\n\t\t\tmax = 'maxX'\n\t\t\tdim = 'width'\n\t\t} else {\n\t\t\tval = 'y'\n\t\t\tmin = 'minY'\n\t\t\tmax = 'maxY'\n\t\t\tdim = 'height'\n\t\t}\n\n\t\tlet shapeGap: number\n\n\t\tif (gap === undefined) {\n\t\t\tconst gaps: { gap: number; count: number }[] = []\n\n\t\t\tshapes.sort((a, b) => pageBounds[a.id][min] - pageBounds[b.id][min])\n\n\t\t\t// Collect all of the gaps between shapes. We want to find\n\t\t\t// patterns (equal gaps between shapes) and use the most common\n\t\t\t// one as the gap for all of the shapes.\n\t\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\t\tconst shape = shapes[i]\n\t\t\t\tconst nextShape = shapes[i + 1]\n\n\t\t\t\tconst bounds = pageBounds[shape.id]\n\t\t\t\tconst nextBounds = pageBounds[nextShape.id]\n\n\t\t\t\tconst gap = nextBounds[min] - bounds[max]\n\n\t\t\t\tconst current = gaps.find((g) => g.gap === gap)\n\n\t\t\t\tif (current) {\n\t\t\t\t\tcurrent.count++\n\t\t\t\t} else {\n\t\t\t\t\tgaps.push({ gap, count: 1 })\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Which gap is the most common?\n\t\t\tlet maxCount = 0\n\t\t\tgaps.forEach((g) => {\n\t\t\t\tif (g.count > maxCount) {\n\t\t\t\t\tmaxCount = g.count\n\t\t\t\t\tshapeGap = g.gap\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// If there is no most-common gap, use the average gap.\n\t\t\tif (maxCount === 1) {\n\t\t\t\tshapeGap = Math.max(0, gaps.reduce((a, c) => a + c.gap * c.count, 0) / (len - 1))\n\t\t\t}\n\t\t} else {\n\t\t\t// If a gap was provided, then use that instead.\n\t\t\tshapeGap = gap\n\t\t}\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tlet v = pageBounds[shapes[0].id][max]\n\n\t\tshapes.forEach((shape, i) => {\n\t\t\tif (i === 0) return\n\n\t\t\tconst delta = { x: 0, y: 0 }\n\t\t\tdelta[val] = v + shapeGap - pageBounds[shape.id][val]\n\n\t\t\tconst parent = this.getParentShape(shape)\n\t\t\tconst localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta\n\n\t\t\tconst translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\tchanges.push(\n\t\t\t\ttranslateStartChanges\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...translateStartChanges,\n\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tid: shape.id as any,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t  }\n\t\t\t)\n\n\t\t\tv += pageBounds[shape.id][dim] + shapeGap\n\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Pack shapes into a grid centered on their current position.\n\t *\n\t * @param ids - The ids of the shapes to pack. Defaults to selected shapes.\n\t * @param padding - The padding to apply to the packed shapes.\n\t */\n\tpackShapes = (ids: TLShapeId[] = this.pageState.selectedIds, padding = 16) => {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapes = compact(\n\t\t\tids.map(this.getShapeById).filter((shape) => {\n\t\t\t\tif (!shape) return false\n\n\t\t\t\tif (TLArrowShapeDef.is(shape)) {\n\t\t\t\t\tif (shape.props.start.type === 'binding' || shape.props.end.type === 'binding') {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true\n\t\t\t})\n\t\t)\n\t\tconst shapePageBounds: Record<string, Box2d> = {}\n\t\tconst nextShapePageBounds: Record<string, Box2d> = {}\n\n\t\tlet shape: TLShape,\n\t\t\tbounds: Box2d,\n\t\t\tarea = 0\n\n\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\tshape = shapes[i]\n\t\t\tbounds = this.getPageBounds(shape)!\n\t\t\tshapePageBounds[shape.id] = bounds\n\t\t\tnextShapePageBounds[shape.id] = bounds.clone()\n\t\t\tarea += bounds.width * bounds.height\n\t\t}\n\n\t\tconst commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))\n\n\t\tconst maxWidth = commonBounds.width\n\n\t\t// sort the shapes by height, descending\n\t\tshapes.sort((a, b) => shapePageBounds[b.id].height - shapePageBounds[a.id].height)\n\n\t\t// Start with is (sort of) the square of the area\n\t\tconst startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth)\n\n\t\t// first shape fills the width and is infinitely tall\n\t\tconst spaces: Box2d[] = [new Box2d(commonBounds.x, commonBounds.y, startWidth, Infinity)]\n\n\t\tlet width = 0\n\t\tlet height = 0\n\t\tlet space: Box2d\n\t\tlet last: Box2d\n\n\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\tshape = shapes[i]\n\t\t\tbounds = nextShapePageBounds[shape.id]\n\n\t\t\t// starting at the back (smaller shapes)\n\t\t\tfor (let i = spaces.length - 1; i >= 0; i--) {\n\t\t\t\tspace = spaces[i]\n\n\t\t\t\t// find a space that is big enough to contain the shape\n\t\t\t\tif (bounds.width > space.width || bounds.height > space.height) continue\n\n\t\t\t\t// add the shape to its top-left corner\n\t\t\t\tbounds.x = space.x\n\t\t\t\tbounds.y = space.y\n\n\t\t\t\theight = Math.max(height, bounds.maxY)\n\t\t\t\twidth = Math.max(width, bounds.maxX)\n\n\t\t\t\tif (bounds.width === space.width && bounds.height === space.height) {\n\t\t\t\t\t// remove the space on a perfect fit\n\t\t\t\t\tlast = spaces.pop()!\n\t\t\t\t\tif (i < spaces.length) spaces[i] = last\n\t\t\t\t} else if (bounds.height === space.height) {\n\t\t\t\t\t// fit the shape into the space (width)\n\t\t\t\t\tspace.x += bounds.width + padding\n\t\t\t\t\tspace.width -= bounds.width + padding\n\t\t\t\t} else if (bounds.width === space.width) {\n\t\t\t\t\t// fit the shape into the space (height)\n\t\t\t\t\tspace.y += bounds.height + padding\n\t\t\t\t\tspace.height -= bounds.height + padding\n\t\t\t\t} else {\n\t\t\t\t\t// split the space into two spaces\n\t\t\t\t\tspaces.push(\n\t\t\t\t\t\tnew Box2d(\n\t\t\t\t\t\t\tspace.x + (bounds.width + padding),\n\t\t\t\t\t\t\tspace.y,\n\t\t\t\t\t\t\tspace.width - (bounds.width + padding),\n\t\t\t\t\t\t\tbounds.height\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\tspace.y += bounds.height + padding\n\t\t\t\t\tspace.height -= bounds.height + padding\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst commonAfter = Box2d.Common(Object.values(nextShapePageBounds))\n\t\tconst centerDelta = Vec2d.Sub(commonBounds.center, commonAfter.center)\n\n\t\tlet nextBounds: Box2d\n\n\t\tconst changes: TLShapePartial<any>[] = []\n\n\t\tfor (let i = 0; i < shapes.length; i++) {\n\t\t\tshape = shapes[i]\n\t\t\tbounds = shapePageBounds[shape.id]\n\t\t\tnextBounds = nextShapePageBounds[shape.id]\n\n\t\t\tconst delta = this.getDeltaInParentSpace(\n\t\t\t\tshape,\n\t\t\t\tVec2d.Sub(nextBounds.point, bounds.point).add(centerDelta)\n\t\t\t)\n\n\t\t\tconst change: TLShapePartial = {\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tx: shape.x + delta.x,\n\t\t\t\ty: shape.y + delta.y,\n\t\t\t}\n\n\t\t\tconst translateStartChange = this.getShapeUtil(shape).onTranslateStart?.({\n\t\t\t\t...shape,\n\t\t\t\t...change,\n\t\t\t} as TLShape)\n\n\t\t\tif (translateStartChange) {\n\t\t\t\tchanges.push({ ...change, ...translateStartChange })\n\t\t\t} else {\n\t\t\t\tchanges.push(change)\n\t\t\t}\n\t\t}\n\n\t\tif (changes.length) {\n\t\t\tthis.updateShapes(changes)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Align shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.alignShapes('left')\n\t * \tapp.alignShapes('left', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - The align operation to apply.\n\t * @param ids - The ids of the shapes to align. Defaults to selected shapes.\n\t * @public\n\t */\n\talignShapes = (\n\t\toperation: 'left' | 'center-horizontal' | 'right' | 'top' | 'center-vertical' | 'bottom',\n\t\tids: TLShapeId[] = this.pageState.selectedIds\n\t) => {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapes = compact(ids.map(this.getShapeById))\n\t\tconst shapePageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)])\n\t\t)\n\t\tconst commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tshapes.forEach((shape) => {\n\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\tif (!pageBounds) return\n\n\t\t\tconst delta = { x: 0, y: 0 }\n\n\t\t\tswitch (operation) {\n\t\t\t\tcase 'top': {\n\t\t\t\t\tdelta.y = commonBounds.minY - pageBounds.minY\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'center-vertical': {\n\t\t\t\t\tdelta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'bottom': {\n\t\t\t\t\tdelta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'left': {\n\t\t\t\t\tdelta.x = commonBounds.minX - pageBounds.minX\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'center-horizontal': {\n\t\t\t\t\tdelta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'right': {\n\t\t\t\t\tdelta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst parent = this.getParentShape(shape)\n\t\t\tconst localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta\n\n\t\t\tconst translateChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\tchanges.push(\n\t\t\t\ttranslateChanges\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...translateChanges,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t  }\n\t\t\t)\n\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Distribute shape positions.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.distributeShapes('left')\n\t * \tapp.distributeShapes('left', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - Whether to distribute shapes horizontally or vertically.\n\t * @param ids - The ids of the shapes to distribute. Defaults to selected shapes.\n\t * @public\n\t */\n\tdistributeShapes = (\n\t\toperation: 'horizontal' | 'vertical',\n\t\tids: TLShapeId[] = this.pageState.selectedIds\n\t) => {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 3) return this\n\n\t\tconst len = ids.length\n\t\tconst shapes = compact(ids.map(this.getShapeById))\n\t\tconst pageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)!])\n\t\t)\n\n\t\tlet val: 'x' | 'y'\n\t\tlet min: 'minX' | 'minY'\n\t\tlet max: 'maxX' | 'maxY'\n\t\tlet mid: 'midX' | 'midY'\n\t\tlet dim: 'width' | 'height'\n\n\t\tif (operation === 'horizontal') {\n\t\t\tval = 'x'\n\t\t\tmin = 'minX'\n\t\t\tmax = 'maxX'\n\t\t\tmid = 'midX'\n\t\t\tdim = 'width'\n\t\t} else {\n\t\t\tval = 'y'\n\t\t\tmin = 'minY'\n\t\t\tmax = 'maxY'\n\t\t\tmid = 'midY'\n\t\t\tdim = 'height'\n\t\t}\n\t\tconst changes: TLShapePartial[] = []\n\n\t\t// Clustered\n\t\tconst first = shapes.sort((a, b) => pageBounds[a.id][min] - pageBounds[b.id][min])[0]\n\t\tconst last = shapes.sort((a, b) => pageBounds[b.id][max] - pageBounds[a.id][max])[0]\n\n\t\tconst midFirst = pageBounds[first.id][mid]\n\t\tconst step = (pageBounds[last.id][mid] - midFirst) / (len - 1)\n\t\tconst v = midFirst + step\n\n\t\tshapes\n\t\t\t.filter((shape) => shape !== first && shape !== last)\n\t\t\t.sort((a, b) => pageBounds[a.id][mid] - pageBounds[b.id][mid])\n\t\t\t.forEach((shape, i) => {\n\t\t\t\tconst delta = { x: 0, y: 0 }\n\t\t\t\tdelta[val] = v + step * i - pageBounds[shape.id][dim] / 2 - pageBounds[shape.id][val]\n\n\t\t\t\tconst parent = this.getParentShape(shape)\n\t\t\t\tconst localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta\n\t\t\t\tconst translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\t\tchanges.push(\n\t\t\t\t\ttranslateStartChanges\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t...translateStartChanges,\n\t\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t\t[val]: shape[val] + localDelta[val],\n\t\t\t\t\t\t  }\n\t\t\t\t)\n\t\t\t})\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\tprivate _resizeUnalignedShape = (\n\t\tid: TLShapeId,\n\t\tscale: VecLike,\n\t\toptions: {\n\t\t\tinitialBounds: Box2d\n\t\t\tscaleOrigin: VecLike\n\t\t\tscaleAxisRotation: number\n\t\t\tinitialShape: TLShape\n\t\t\tinitialPageTransform: MatLike\n\t\t}\n\t) => {\n\t\tconst { type } = options.initialShape\n\t\t// If a shape is not aligned with the scale axis we need to treat it differently to avoid skewing.\n\t\t// Instead of skewing we normalise the scale aspect ratio (i.e. keep the same scale magnitude in both axes)\n\t\t// and then after applying the scale to the shape we also rotate it if required and translate it so that it's center\n\t\t// point ends up in the right place.\n\n\t\tconst shapeScale = new Vec2d(scale.x, scale.y)\n\n\t\t// // make sure we are contraining aspect ratio, and using the smallest scale axis to avoid shapes getting bigger\n\t\t// // than the selection bounding box\n\t\tif (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\tshapeScale.x = Math.sign(scale.x) * Math.abs(scale.y)\n\t\t} else {\n\t\t\tshapeScale.y = Math.sign(scale.y) * Math.abs(scale.x)\n\t\t}\n\n\t\t// first we can scale the shape about its center point\n\t\tthis.resizeShape(id, shapeScale, {\n\t\t\tinitialShape: options.initialShape,\n\t\t\tinitialBounds: options.initialBounds,\n\t\t})\n\n\t\t// then if the shape is flipped in one axis only, we need to apply an extra rotation\n\t\t// to make sure the shape is mirrored correctly\n\t\tif (Math.sign(scale.x) * Math.sign(scale.y) < 0) {\n\t\t\tlet { rotation } = Matrix2d.Decompose(options.initialPageTransform)\n\t\t\trotation -= 2 * rotation\n\t\t\tthis.updateShapes([{ id, type, rotation }], true)\n\t\t}\n\n\t\t// Next we need to translate the shape so that it's center point ends up in the right place.\n\t\t// To do that we first need to calculate the center point of the shape in page space before the scale was applied.\n\t\tconst preScaleShapePageCenter = Matrix2d.applyToPoint(\n\t\t\toptions.initialPageTransform,\n\t\t\toptions.initialBounds.center\n\t\t)\n\n\t\t// And now we scale the center point by the original scale factor\n\t\tconst postScaleShapePageCenter = this._scalePagePoint(\n\t\t\tpreScaleShapePageCenter,\n\t\t\toptions.scaleOrigin,\n\t\t\tscale,\n\t\t\toptions.scaleAxisRotation\n\t\t)\n\n\t\t// now caculate how far away the shape is from where it needs to be\n\t\tconst currentPageCenter = this.getPageCenterById(id)\n\t\tconst currentPagePoint = this.getPagePointById(id)\n\t\tif (!currentPageCenter || !currentPagePoint) return this\n\t\tconst pageDelta = Vec2d.Sub(postScaleShapePageCenter, currentPageCenter)\n\n\t\t// and finally figure out what the shape's new position should be\n\t\tconst postScaleShapePagePoint = Vec2d.Add(currentPagePoint, pageDelta)\n\t\tconst { x, y } = this.getPointInParentSpace(id, postScaleShapePagePoint)\n\n\t\tthis.updateShapes([{ id, type, x, y }], true)\n\n\t\treturn this\n\t}\n\n\t_scalePagePoint = (\n\t\tpoint: VecLike,\n\t\tscaleOrigin: VecLike,\n\t\tscale: VecLike,\n\t\tscaleAxisRotation: number\n\t) => {\n\t\tconst relativePoint = Vec2d.RotWith(point, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin)\n\n\t\t// calculate the new point position relative to the scale origin\n\t\tconst newRelativePagePoint = Vec2d.MulV(relativePoint, scale)\n\n\t\t// and rotate it back to page coords to get the new page point of the resized shape\n\t\tconst destination = Vec2d.Add(newRelativePagePoint, scaleOrigin).rotWith(\n\t\t\tscaleOrigin,\n\t\t\tscaleAxisRotation\n\t\t)\n\n\t\treturn destination\n\t}\n\n\tresizeShape = (\n\t\tid: TLShapeId,\n\t\tscale: VecLike,\n\t\toptions?: {\n\t\t\tinitialBounds?: Box2d\n\t\t\tscaleOrigin?: VecLike\n\t\t\tscaleAxisRotation?: number\n\t\t\tinitialShape?: TLShape\n\t\t\tinitialPageTransform?: MatLike\n\t\t\tdragHandle?: TLResizeHandle\n\t\t\tmode?: TLResizeMode\n\t\t}\n\t) => {\n\t\tif (this.isReadOnly) return this\n\n\t\tif (!Number.isFinite(scale.x)) scale = new Vec2d(1, scale.y)\n\t\tif (!Number.isFinite(scale.y)) scale = new Vec2d(scale.x, 1)\n\n\t\tconst initialShape = options?.initialShape ?? this.getShapeById(id)\n\t\tif (!initialShape) return this\n\n\t\tconst scaleOrigin = options?.scaleOrigin ?? this.getPageBoundsById(id)?.center\n\t\tif (!scaleOrigin) return this\n\n\t\tconst pageRotation = this.getPageRotationById(id)\n\n\t\tif (pageRotation == null) return this\n\n\t\tconst scaleAxisRotation = options?.scaleAxisRotation ?? pageRotation\n\n\t\tconst pageTransform = options?.initialPageTransform ?? this.getPageTransformById(id)\n\t\tif (!pageTransform) return this\n\n\t\tconst initialBounds = options?.initialBounds ?? this.getBoundsById(id)\n\n\t\tif (!initialBounds) return this\n\n\t\tif (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {\n\t\t\t// shape is awkwardly rotated, keep the aspect ratio locked and adopt the scale factor\n\t\t\t// from whichever axis is being scaled the least, to avoid the shape getting bigger\n\t\t\t// than the bounds of the selection\n\t\t\t// const minScale = Math.min(Math.abs(scale.x), Math.abs(scale.y))\n\t\t\treturn this._resizeUnalignedShape(id, scale, {\n\t\t\t\t...options,\n\t\t\t\tinitialBounds,\n\t\t\t\tscaleOrigin,\n\t\t\t\tscaleAxisRotation,\n\t\t\t\tinitialPageTransform: pageTransform,\n\t\t\t\tinitialShape,\n\t\t\t})\n\t\t}\n\n\t\tconst util = this.getShapeUtil(initialShape)\n\n\t\tif (util.isAspectRatioLocked(initialShape)) {\n\t\t\tif (Math.abs(scale.x) > Math.abs(scale.y)) {\n\t\t\t\tscale = new Vec2d(scale.x, Math.sign(scale.y) * Math.abs(scale.x))\n\t\t\t} else {\n\t\t\t\tscale = new Vec2d(Math.sign(scale.x) * Math.abs(scale.y), scale.y)\n\t\t\t}\n\t\t}\n\n\t\tif (util.onResize && util.canResize(initialShape)) {\n\t\t\t// get the model changes from the shape util\n\t\t\tconst newPagePoint = this._scalePagePoint(\n\t\t\t\tMatrix2d.applyToPoint(pageTransform, new Vec2d(0, 0)),\n\t\t\t\tscaleOrigin,\n\t\t\t\tscale,\n\t\t\t\tscaleAxisRotation\n\t\t\t)\n\n\t\t\tconst newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint)\n\n\t\t\t// resize the shape's local bounding box\n\t\t\tconst myScale = new Vec2d(scale.x, scale.y)\n\t\t\t// the shape is algined with the rest of the shpaes in the selection, but may be\n\t\t\t// 90deg offset from the main rotation of the selection, in which case\n\t\t\t// we need to flip the width and height scale factors\n\t\t\tconst areWidthAndHeightAlignedWithCorrectAxis = approximately(\n\t\t\t\t(pageRotation - scaleAxisRotation) % Math.PI,\n\t\t\t\t0\n\t\t\t)\n\t\t\tmyScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y\n\t\t\tmyScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x\n\n\t\t\t// adjust initial model for situations where the parent has moved during the resize\n\t\t\t// e.g. groups\n\t\t\tconst initialPagePoint = Matrix2d.applyToPoint(pageTransform, new Vec2d())\n\n\t\t\t// need to adjust the shape's x and y points in case the parent has moved since start of resizing\n\t\t\tconst { x, y } = this.getPointInParentSpace(initialShape.id, initialPagePoint)\n\n\t\t\tthis.updateShapes(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: initialShape.type as any,\n\t\t\t\t\t\tx: newLocalPoint.x,\n\t\t\t\t\t\ty: newLocalPoint.y,\n\t\t\t\t\t\t...util.onResize(\n\t\t\t\t\t\t\t{ ...initialShape, x, y },\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tnewPoint: newLocalPoint,\n\t\t\t\t\t\t\t\thandle: options?.dragHandle ?? 'bottom_right',\n\t\t\t\t\t\t\t\t// don't set isSingle to true for children\n\t\t\t\t\t\t\t\tmode: options?.mode ?? 'scale_shape',\n\t\t\t\t\t\t\t\tscaleX: myScale.x,\n\t\t\t\t\t\t\t\tscaleY: myScale.y,\n\t\t\t\t\t\t\t\tinitialBounds,\n\t\t\t\t\t\t\t\tinitialShape,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttrue\n\t\t\t)\n\t\t} else {\n\t\t\tconst initialPageCenter = Matrix2d.applyToPoint(pageTransform, initialBounds.center)\n\t\t\t// get the model changes from the shape util\n\t\t\tconst newPageCenter = this._scalePagePoint(\n\t\t\t\tinitialPageCenter,\n\t\t\t\tscaleOrigin,\n\t\t\t\tscale,\n\t\t\t\tscaleAxisRotation\n\t\t\t)\n\n\t\t\tconst initialPageCenterInParentSpace = this.getPointInParentSpace(\n\t\t\t\tinitialShape.id,\n\t\t\t\tinitialPageCenter\n\t\t\t)\n\t\t\tconst newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter)\n\n\t\t\tconst delta = Vec2d.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace)\n\t\t\t// apply the changes to the model\n\t\t\tthis.updateShapes(\n\t\t\t\t[\n\t\t\t\t\t{\n\t\t\t\t\t\tid,\n\t\t\t\t\t\ttype: initialShape.type as any,\n\t\t\t\t\t\tx: initialShape.x + delta.x,\n\t\t\t\t\t\ty: initialShape.y + delta.y,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\ttrue\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Stretch shape sizes and positions to fill their common bounding box.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.stretchShapes('horizontal')\n\t * \tapp.stretchShapes('horizontal', ['box1', 'box2'])\n\t * ```\n\t *\n\t * @param operation - Whether to stretch shapes horizontally or vertically.\n\t * @param ids - The ids of the shapes to stretch. Defaults to selected shapes.\n\t * @public\n\t */\n\tstretchShapes = (\n\t\toperation: 'horizontal' | 'vertical',\n\t\tids: TLShapeId[] = this.pageState.selectedIds\n\t) => {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length < 2) return this\n\n\t\tconst shapes = compact(ids.map(this.getShapeById))\n\t\tconst shapeBounds = Object.fromEntries(shapes.map((shape) => [shape.id, this.getBounds(shape)]))\n\t\tconst shapePageBounds = Object.fromEntries(\n\t\t\tshapes.map((shape) => [shape.id, this.getPageBounds(shape)!])\n\t\t)\n\t\tconst commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)))\n\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tswitch (operation) {\n\t\t\tcase 'vertical': {\n\t\t\t\tthis.batch(() => {\n\t\t\t\t\tfor (const shape of shapes) {\n\t\t\t\t\t\tconst pageRotation = this.getPageRotation(shape)\n\t\t\t\t\t\tif (pageRotation % PI2) continue\n\t\t\t\t\t\tconst bounds = shapeBounds[shape.id]\n\t\t\t\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\t\t\t\tconst localOffset = this.getDeltaInParentSpace(\n\t\t\t\t\t\t\tshape,\n\t\t\t\t\t\t\tnew Vec2d(0, commonBounds.minY - pageBounds.minY)\n\t\t\t\t\t\t)\n\t\t\t\t\t\tconst { x, y } = Vec2d.Add(localOffset, shape)\n\t\t\t\t\t\tthis.updateShapes([{ id: shape.id, type: shape.type, x, y }], true)\n\t\t\t\t\t\tconst scale = new Vec2d(1, commonBounds.height / pageBounds.height)\n\t\t\t\t\t\tthis.resizeShape(shape.id, scale, {\n\t\t\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\t\t\tscaleOrigin: new Vec2d(pageBounds.center.x, commonBounds.minY),\n\t\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase 'horizontal': {\n\t\t\t\tthis.batch(() => {\n\t\t\t\t\tfor (const shape of shapes) {\n\t\t\t\t\t\tconst bounds = shapeBounds[shape.id]\n\t\t\t\t\t\tconst pageBounds = shapePageBounds[shape.id]\n\t\t\t\t\t\tconst pageRotation = this.getPageRotation(shape)\n\t\t\t\t\t\tif (pageRotation % PI2) continue\n\t\t\t\t\t\tconst localOffset = this.getDeltaInParentSpace(\n\t\t\t\t\t\t\tshape,\n\t\t\t\t\t\t\tnew Vec2d(commonBounds.minX - pageBounds.minX, 0)\n\t\t\t\t\t\t)\n\t\t\t\t\t\tconst { x, y } = Vec2d.Add(localOffset, shape)\n\t\t\t\t\t\tthis.updateShapes([{ id: shape.id, type: shape.type, x, y }], true)\n\t\t\t\t\t\tconst scale = new Vec2d(commonBounds.width / pageBounds.width, 1)\n\t\t\t\t\t\tthis.resizeShape(shape.id, scale, {\n\t\t\t\t\t\t\tinitialBounds: bounds,\n\t\t\t\t\t\t\tscaleOrigin: new Vec2d(commonBounds.minX, pageBounds.center.y),\n\t\t\t\t\t\t\tscaleAxisRotation: 0,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Reparent shapes to a new parent. This operation preserves the shape's current page positions /\n\t * rotations.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.reparentShapes(['box1', 'box2'], 'frame1')\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to reparent.\n\t * @param parentId - The id of the new parent shape.\n\t * @param insertIndex - The index to insert the children.\n\t * @public\n\t */\n\treparentShapes = (ids: TLShapeId[], parentId: TLParentId, insertIndex?: string) => {\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tconst parentTransform = TLPage.isId(parentId)\n\t\t\t? Matrix2d.Identity()\n\t\t\t: this.getPageTransformById(parentId)!\n\n\t\tconst parentPageRotation = parentTransform.decompose().rotation\n\n\t\tlet indices: string[] = []\n\n\t\tconst sibs = compact(this.getSortedChildren(parentId).map(this.getShapeById))\n\n\t\tif (insertIndex) {\n\t\t\tconst sibWithInsertIndex = sibs.find((s) => s.index === insertIndex)\n\t\t\tif (sibWithInsertIndex) {\n\t\t\t\t// If there's a sibling with the same index as the insert index...\n\t\t\t\tconst sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1]\n\t\t\t\tif (sibAbove) {\n\t\t\t\t\t// If the sibling has a sibling above it, insert the shapes\n\t\t\t\t\t// between the sibling and its sibling above it.\n\t\t\t\t\tindices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)\n\t\t\t\t} else {\n\t\t\t\t\t// Or if the sibling is the top sibling, insert the shapes\n\t\t\t\t\t// above the sibling\n\t\t\t\t\tindices = getIndicesAbove(insertIndex, ids.length)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If there's no collision, then we can start at the insert index\n\t\t\t\tconst sibAbove = sibs.sort(sortByIndex).find((s) => s.index > insertIndex)\n\n\t\t\t\tif (sibAbove) {\n\t\t\t\t\t// If the siblings include a sibling with a higher index, insert the shapes\n\t\t\t\t\t// between the insert index and the sibling with the higher index.\n\t\t\t\t\tindices = getIndicesBetween(insertIndex, sibAbove.index, ids.length)\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, we're at the top of the order, so insert the shapes above\n\t\t\t\t\t// the insert index.\n\t\t\t\t\tindices = getIndicesAbove(insertIndex, ids.length)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// If insert index is not specified, start the index at the top.\n\t\t\tconst sib = sibs.length && sibs[sibs.length - 1]\n\t\t\tindices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length)\n\t\t}\n\n\t\tlet id: TLShapeId\n\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\tid = ids[i]\n\t\t\tconst shape = this.getShapeById(id)\n\t\t\tconst pagePoint = this.getPagePointById(id)\n\n\t\t\tif (!shape || !pagePoint) continue\n\n\t\t\tconst newPoint = Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), pagePoint)\n\t\t\tconst newRotation = this.getPageRotation(shape) - parentPageRotation\n\n\t\t\tchanges.push({\n\t\t\t\tid: shape.id,\n\t\t\t\ttype: shape.type,\n\t\t\t\tparentId: parentId,\n\t\t\t\tx: newPoint.x,\n\t\t\t\ty: newPoint.y,\n\t\t\t\trotation: newRotation,\n\t\t\t\tindex: indices[i],\n\t\t\t})\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\t\treturn this\n\t}\n\n\t/**\n\t * Select one or more shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.select('id1')\n\t * \tapp.select('id1', 'id2')\n\t * ```\n\t *\n\t * @param ids - The ids to select.\n\t * @public\n\t */\n\tselect = (...ids: TLShapeId[]) => {\n\t\tthis.setSelectedIds(ids)\n\t\treturn this\n\t}\n\n\t/**\n\t * Remove a shpae from the existing set of selected shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.deselect(shape.id)\n\t * ```\n\t *\n\t * @public\n\t */\n\tdeselect = (...ids: TLShapeId[]) => {\n\t\tconst { selectedIds } = this\n\t\tif (selectedIds.length > 0 && ids.length > 0) {\n\t\t\tthis.setSelectedIds(selectedIds.filter((id) => !ids.includes(id)))\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Select all direct children of the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.selectAll()\n\t * ```\n\t *\n\t * @public\n\t */\n\tselectAll = () => {\n\t\tconst ids = this.getSortedChildren(this.currentPageId)\n\t\t// page might have no shapes\n\t\tif (ids.length <= 0) return this\n\t\tthis.setSelectedIds(ids)\n\t\treturn this\n\t}\n\n\tgetShapesAndDescendantsInOrder(ids: TLShapeId[]) {\n\t\tconst idsToInclude: TLShapeId[] = []\n\t\tconst visitedIds = new Set<string>()\n\n\t\tconst idsToCheck = [...ids]\n\n\t\twhile (idsToCheck.length > 0) {\n\t\t\tconst id = idsToCheck.pop()\n\t\t\tif (!id) break\n\t\t\tif (visitedIds.has(id)) continue\n\t\t\tidsToInclude.push(id)\n\t\t\tthis.getSortedChildren(id).forEach((id) => {\n\t\t\t\tidsToCheck.push(id)\n\t\t\t})\n\t\t}\n\n\t\t// Map the ids into nodes AND their descendants\n\t\tconst shapes = idsToInclude.map((s) => this.getShapeById(s)!).filter((s) => s.type !== 'group')\n\n\t\t// Sort by the shape's appearance in the sorted shapes array\n\t\tconst { sortedShapesArray } = this\n\t\tshapes.sort((a, b) => sortedShapesArray.indexOf(a) - sortedShapesArray.indexOf(b))\n\n\t\treturn shapes\n\t}\n\n\t/**\n\t * Clear the selection.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.selectNone()\n\t * ```\n\t *\n\t * @public\n\t */\n\tselectNone = () => {\n\t\tif (this.selectedIds.length > 0) {\n\t\t\tthis.setSelectedIds([])\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current page.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setCurrentPage('page1')\n\t * ```\n\t *\n\t * @param pageId - The id of the page to set as the current page.\n\t * @public\n\t */\n\tsetCurrentPage = this.history.createCommand(\n\t\t'setCurrentPage',\n\t\t(pageId: TLPageId) => {\n\t\t\tif (!this.store.has(pageId)) {\n\t\t\t\tconsole.error(\"Tried to set the current page id to a page that doesn't exist.\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdata: { pageId, prev: this.currentPageId },\n\t\t\t\tsquashing: true,\n\t\t\t\tpreservesRedoStack: true,\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ pageId }) => {\n\t\t\t\tif (!this.getPageStateByPageId(pageId)) {\n\t\t\t\t\tconst camera = TLCamera.create({})\n\t\t\t\t\tthis.store.put([\n\t\t\t\t\t\tcamera,\n\t\t\t\t\t\tTLInstancePageState.create({\n\t\t\t\t\t\t\tpageId,\n\t\t\t\t\t\t\tinstanceId: this.instanceId,\n\t\t\t\t\t\t\tcameraId: camera.id,\n\t\t\t\t\t\t}),\n\t\t\t\t\t])\n\t\t\t\t}\n\n\t\t\t\tthis.store.put([{ ...this.instanceState, currentPageId: pageId }])\n\n\t\t\t\tthis.updateCullingViewport()\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.put([{ ...this.instanceState, currentPageId: prev }])\n\n\t\t\t\tthis.updateCullingViewport()\n\t\t\t},\n\t\t\tsquash: ({ prev }, { pageId }) => {\n\t\t\t\treturn { pageId, prev }\n\t\t\t},\n\t\t}\n\t)\n\n\t/** Set the current user tab state */\n\tupdateInstanceState = this.history.createCommand(\n\t\t'updateTabState',\n\t\t(\n\t\t\tpartial: Partial<Omit<TLInstance, 'documentId' | 'userId' | 'currentPageId'>>,\n\t\t\tephemeral = false,\n\t\t\tsquashing = false\n\t\t) => {\n\t\t\tconst prev = this.instanceState\n\t\t\tconst next = { ...prev, ...partial }\n\n\t\t\treturn {\n\t\t\t\tdata: { prev, next },\n\t\t\t\tsquashing,\n\t\t\t\tephemeral,\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tdo: ({ next }) => {\n\t\t\t\tthis.store.put([next])\n\t\t\t},\n\t\t\tundo: ({ prev }) => {\n\t\t\t\tthis.store.put([prev])\n\t\t\t},\n\t\t\tsquash({ prev }, { next }) {\n\t\t\t\treturn { prev, next }\n\t\t\t},\n\t\t}\n\t)\n\n\t@computed get hoveredId() {\n\t\treturn this.pageState.hoveredId\n\t}\n\n\t@computed get hoveredShape() {\n\t\tif (!this.hoveredId) return null\n\t\treturn this.getShapeById(this.hoveredId) ?? null\n\t}\n\n\t/**\n\t * Set the current hovered shape.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setHoveredId('box1')\n\t * \tapp.setHoveredId() // Clears the hovered shape.\n\t * ```\n\t *\n\t * @param id - The id of the page to set as the current page\n\t * @public\n\t */\n\tsetHoveredId = (id: TLShapeId | null = null) => {\n\t\tif (id === this.pageState.hoveredId) return this\n\n\t\tthis.setPageState({ hoveredId: id }, true)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current erasing shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setErasingIds(['box1', 'box2'])\n\t * \tapp.setErasingIds() // Clears the erasing set\n\t * ```\n\t *\n\t * @param ids - The ids of shapes to set as erasing.\n\t * @public\n\t */\n\tsetErasingIds = (ids: TLShapeId[] = []) => {\n\t\tconst erasingIds = this.erasingIdsSet\n\t\tif (ids.length === erasingIds.size && ids.every((id) => erasingIds.has(id))) return this\n\n\t\tthis.setPageState({ erasingIds: ids }, true)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current cursor.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setCursor({ type: 'default' })\n\t * \tapp.setCursor({ type: 'default', rotation: Math.PI / 2, color: 'red' })\n\t * ```\n\t *\n\t * @param cursor - A partial of the cursor object.\n\t * @public\n\t */\n\tsetCursor = (cursor: Partial<TLCursor>) => {\n\t\tconst current = this.cursor\n\t\tconst next = {\n\t\t\t...current,\n\t\t\trotation: 0,\n\t\t\t...cursor,\n\t\t}\n\n\t\tif (\n\t\t\t!(\n\t\t\t\tcurrent.type === next.type &&\n\t\t\t\tcurrent.rotation === next.rotation &&\n\t\t\t\tcurrent.color === next.color\n\t\t\t)\n\t\t) {\n\t\t\tthis.updateInstanceState({ cursor: next }, true)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current scribble.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setScribble(nextScribble)\n\t * \tapp.setScribble() // clears the scribble\n\t * ```\n\t *\n\t * @param scribble - The new scribble object.\n\t * @public\n\t */\n\tsetScribble = (scribble: TLScribble | null = null) => {\n\t\tthis.updateInstanceState({ scribble }, true)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current brush.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setBrush({ x: 0, y: 0, w: 100, h: 100 })\n\t * \tapp.setBrush() // Clears the brush\n\t * ```\n\t *\n\t * @param brush - The brush box model to set, or null for no brush model.\n\t * @public\n\t */\n\tsetBrush = (brush: Box2dModel | null = null) => {\n\t\t!brush && !this.brush\n\t\tthis.batch(() => {\n\t\t\tthis.updateInstanceState({ brush }, true)\n\t\t})\n\t\treturn this\n\t}\n\n\t/**\n\t * Rotate shapes by a delta in radians.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.rotateShapesBy(['box1', 'box2'], Math.PI)\n\t * \tapp.rotateShapesBy(['box1', 'box2'], 'Math.PI / 2)\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move.\n\t * @param delta - The delta in radians to apply to the selection rotation.\n\t */\n\trotateShapesBy = (ids: TLShapeId[], delta: number) => {\n\t\tif (ids.length <= 0) return this\n\n\t\tconst snapshot = getRotationSnapshot({ app: this })\n\t\tapplyRotationToSnapshotShapes({ delta, snapshot, app: this, stage: 'one-off' })\n\t}\n\n\t/**\n\t * Move shapes by a delta.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.nudgeShapes(['box1', 'box2'], 'left')\n\t * \tapp.nudgeShapes(['box1', 'box2'], 'left', true)\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to move.\n\t * @param direction - The direction in which to move the shapes.\n\t * @param major - Whether this is a major nudge, e.g. a shift + arrow nudge.\n\t */\n\tnudgeShapes = (ids: TLShapeId[], direction: TLDeltaDirection, major = false) => {\n\t\tif (ids.length <= 0) return this\n\n\t\tconst step = this.isGridMode\n\t\t\t? major\n\t\t\t\t? this.gridSize * GRID_INCREMENT\n\t\t\t\t: this.gridSize\n\t\t\t: major\n\t\t\t? MAJOR_NUDGE_FACTOR\n\t\t\t: MINOR_NUDGE_FACTOR\n\n\t\tconst steppedDelta = Vec2d.Mul(DIRECTION_DELTAS[direction], step)\n\t\tconst changes: TLShapePartial[] = []\n\n\t\tfor (const id of ids) {\n\t\t\tconst shape = this.getShapeById(id)\n\n\t\t\tif (!shape) {\n\t\t\t\tthrow Error(`Could not find a shape with the id ${id}.`)\n\t\t\t}\n\n\t\t\tconst localDelta = this.getDeltaInParentSpace(shape, steppedDelta)\n\t\t\tconst translateStartChanges = this.getShapeUtil(shape).onTranslateStart?.(shape)\n\n\t\t\tchanges.push(\n\t\t\t\ttranslateStartChanges\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...translateStartChanges,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tx: shape.x + localDelta.x,\n\t\t\t\t\t\t\ty: shape.y + localDelta.y,\n\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t  }\n\t\t\t)\n\t\t}\n\n\t\tthis.updateShapes(changes)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Duplicate shapes.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.duplicateShapes()\n\t * \tapp.duplicateShapes(['id1', 'id2'])\n\t * \tapp.duplicateShapes(['id1', 'id2'], { x: 8, y: 8 })\n\t * ```\n\t *\n\t * @param ids - The ids of the shapes to duplicate. Defaults to the ids of the selected\n\t *   shapes.\n\t * @param offset - The offset (in pixels) to apply to the duplicated shapes.\n\t * @public\n\t */\n\tduplicateShapes = (ids: TLShapeId[] = this.selectedIds, offset?: VecLike) => {\n\t\tif (ids.length <= 0) return this\n\n\t\tconst initialIds = new Set(ids)\n\t\tconst idsToCreate: TLShapeId[] = []\n\t\tconst idsToCheck = [...ids]\n\n\t\twhile (idsToCheck.length > 0) {\n\t\t\tconst id = idsToCheck.pop()\n\t\t\tif (!id) break\n\t\t\tidsToCreate.push(id)\n\t\t\tthis.getSortedChildren(id).forEach((childId) => idsToCheck.push(childId))\n\t\t}\n\n\t\tidsToCreate.reverse()\n\n\t\tconst idsMap = new Map<any, TLShapeId>(idsToCreate.map((id) => [id, this.createShapeId()]))\n\n\t\tconst shapesToCreate = compact(\n\t\t\tidsToCreate.map((id) => {\n\t\t\t\tconst shape = this.getShapeById(id)\n\n\t\t\t\tif (!shape) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\n\t\t\t\tconst createId = idsMap.get(id)!\n\n\t\t\t\tlet ox = 0\n\t\t\t\tlet oy = 0\n\n\t\t\t\tif (offset && initialIds.has(id)) {\n\t\t\t\t\tconst parentTransform = this.getParentTransform(shape)\n\t\t\t\t\tconst vec = new Vec2d(offset.x, offset.y).rot(\n\t\t\t\t\t\t-Matrix2d.Decompose(parentTransform).rotation\n\t\t\t\t\t)\n\t\t\t\t\tox = vec.x\n\t\t\t\t\toy = vec.y\n\t\t\t\t}\n\n\t\t\t\tconst parentId = shape.parentId ?? this.currentPageId\n\t\t\t\tconst siblings = this.getSortedChildren(parentId)\n\t\t\t\tconst currentIndex = siblings.indexOf(shape.id)\n\t\t\t\tconst siblingAboveId = siblings[currentIndex + 1]\n\t\t\t\tconst siblingAbove = siblingAboveId ? this.getShapeById(siblingAboveId) : null\n\n\t\t\t\tconst index = siblingAbove\n\t\t\t\t\t? getIndexBetween(shape.index, siblingAbove.index)\n\t\t\t\t\t: getIndexAbove(shape.index)\n\n\t\t\t\tconst newShape: TLShape = {\n\t\t\t\t\t...deepCopy(shape),\n\t\t\t\t\tid: createId,\n\t\t\t\t\tx: shape.x + ox,\n\t\t\t\t\ty: shape.y + oy,\n\t\t\t\t\tindex,\n\t\t\t\t}\n\n\t\t\t\tif (TLArrowShapeDef.is(shape) && TLArrowShapeDef.is(newShape)) {\n\t\t\t\t\tif (shape.props.start.type === 'binding') {\n\t\t\t\t\t\tconst newBoundShapeId = idsMap.get(shape.props.start.boundShapeId)\n\n\t\t\t\t\t\tif (newBoundShapeId) {\n\t\t\t\t\t\t\t;(newShape.props.start as TLArrowTerminal & { type: 'binding' }).boundShapeId =\n\t\t\t\t\t\t\t\tnewBoundShapeId\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst bounds = this.getPageBoundsById(shape.props.start.boundShapeId)!\n\t\t\t\t\t\t\tconst pointInTargetSpace = new Vec2d(\n\t\t\t\t\t\t\t\tshape.props.start.normalizedAnchor.x * bounds.width + bounds.minX,\n\t\t\t\t\t\t\t\tshape.props.start.normalizedAnchor.y * bounds.height + bounds.minY\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tconst pointInArrowSpace = Matrix2d.applyToPoint(\n\t\t\t\t\t\t\t\tMatrix2d.Inverse(this.getTransform(newShape)),\n\t\t\t\t\t\t\t\tpointInTargetSpace\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tnewShape.props.start = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx: pointInArrowSpace.x + ox,\n\t\t\t\t\t\t\t\ty: pointInArrowSpace.y + oy,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (shape.props.end.type === 'binding') {\n\t\t\t\t\t\tconst newBoundShapeId = idsMap.get(shape.props.end.boundShapeId)\n\n\t\t\t\t\t\tif (newBoundShapeId) {\n\t\t\t\t\t\t\t;(newShape.props.end as TLArrowTerminal & { type: 'binding' }).boundShapeId =\n\t\t\t\t\t\t\t\tnewBoundShapeId\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst bounds = this.getPageBoundsById(shape.props.end.boundShapeId)!\n\t\t\t\t\t\t\tconst pointInTargetSpace = new Vec2d(\n\t\t\t\t\t\t\t\tshape.props.end.normalizedAnchor.x * bounds.width + bounds.minX,\n\t\t\t\t\t\t\t\tshape.props.end.normalizedAnchor.y * bounds.height + bounds.minY\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tconst pointInArrowSpace = Matrix2d.applyToPoint(\n\t\t\t\t\t\t\t\tMatrix2d.Inverse(this.getTransform(newShape)),\n\t\t\t\t\t\t\t\tpointInTargetSpace\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tnewShape.props.end = {\n\t\t\t\t\t\t\t\ttype: 'point',\n\t\t\t\t\t\t\t\tx: pointInArrowSpace.x + ox,\n\t\t\t\t\t\t\t\ty: pointInArrowSpace.y + oy,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn newShape\n\t\t\t})\n\t\t)\n\n\t\tshapesToCreate.forEach((shape) => {\n\t\t\tif (isShapeId(shape.parentId)) {\n\t\t\t\tif (idsMap.has(shape.parentId)) {\n\t\t\t\t\tshape.parentId = idsMap.get(shape.parentId)!\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tthis.history.batch(() => {\n\t\t\tconst maxShapesReached = shapesToCreate.length + this.shapeIds.size > MAX_SHAPES_PER_PAGE\n\n\t\t\tif (maxShapesReached) {\n\t\t\t\talertMaxShapes(this)\n\t\t\t}\n\n\t\t\tconst newShapes = maxShapesReached\n\t\t\t\t? shapesToCreate.slice(0, MAX_SHAPES_PER_PAGE - this.shapeIds.size)\n\t\t\t\t: shapesToCreate\n\n\t\t\tconst ids = newShapes.map((s) => s.id)\n\n\t\t\tthis.createShapes(newShapes)\n\t\t\tthis.setSelectedIds(ids)\n\n\t\t\tif (offset !== undefined) {\n\t\t\t\t// If we've offset the duplicated shapes, check to see whether their new bounds is entirely\n\t\t\t\t// contained in the current viewport. If not, then animate the camera to be centered on the\n\t\t\t\t// new shapes.\n\t\t\t\tconst { viewport, selectedPageBounds } = this\n\t\t\t\tif (selectedPageBounds && !viewport.contains(selectedPageBounds)) {\n\t\t\t\t\tthis.centerOnPoint(selectedPageBounds.center.x, selectedPageBounds.center.y, {\n\t\t\t\t\t\tduration: ANIMATION_MEDIUM_MS,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current props (generally styles).\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setProp('color', 'red')\n\t * \tapp.setProp('color', 'red', true)\n\t * ```\n\t *\n\t * @param key - The key to set.\n\t * @param value - The value to set.\n\t * @param ephemeral - Whether the style is ephemeral. Defaults to false.\n\t * @public\n\t */\n\tsetProp = (key: TLShapeProp, value: any, ephemeral = false, squashing = false) => {\n\t\tconst children: (TLShape | undefined)[] = []\n\t\t// We can have many deep levels of grouped shape\n\t\t// Making a recursive function to look through all the levels\n\t\tconst getChildProp = (id: TLShape['id']) => {\n\t\t\tconst childIds = this.getSortedChildren(id)\n\t\t\tfor (const childId of childIds) {\n\t\t\t\tconst childShape = this.getShapeById(childId)\n\t\t\t\tif (childShape?.type === 'group') {\n\t\t\t\t\tgetChildProp(childShape.id)\n\t\t\t\t}\n\t\t\t\tchildren.push(childShape)\n\t\t\t}\n\t\t}\n\n\t\tthis.history.batch(() => {\n\t\t\tthis.updateInstanceState(\n\t\t\t\t{\n\t\t\t\t\tpropsForNextShape: setPropsForNextShape(this.instanceState.propsForNextShape, {\n\t\t\t\t\t\t[key]: value,\n\t\t\t\t\t}),\n\t\t\t\t},\n\t\t\t\tephemeral,\n\t\t\t\tsquashing\n\t\t\t)\n\n\t\t\tif (this.isIn('select')) {\n\t\t\t\tconst {\n\t\t\t\t\tpageState: { selectedIds },\n\t\t\t\t} = this\n\n\t\t\t\tif (selectedIds.length > 0) {\n\t\t\t\t\tconst shapes = compact(\n\t\t\t\t\t\tselectedIds.map((id) => {\n\t\t\t\t\t\t\tconst shape = this.getShapeById(id)\n\t\t\t\t\t\t\tif (shape?.type === 'group') {\n\t\t\t\t\t\t\t\tconst childIds = this.getSortedChildren(shape.id)\n\t\t\t\t\t\t\t\tfor (const childId of childIds) {\n\t\t\t\t\t\t\t\t\tconst childShape = this.getShapeById(childId)\n\t\t\t\t\t\t\t\t\tif (childShape?.type === 'group') {\n\t\t\t\t\t\t\t\t\t\tgetChildProp(childShape.id)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tchildren.push(childShape)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn children\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn shape\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t\t\t.flat()\n\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t(shape) =>\n\t\t\t\t\t\t\t\tshape!.props[key as keyof TLShape['props']] !== undefined && shape?.type !== 'group'\n\t\t\t\t\t\t) as TLShape[]\n\n\t\t\t\t\tthis.updateShapes(\n\t\t\t\t\t\tshapes.map((shape) => {\n\t\t\t\t\t\t\tconst props = { ...shape.props, [key]: value }\n\t\t\t\t\t\t\tif (key === 'color' && 'labelColor' in props) {\n\t\t\t\t\t\t\t\tprops.labelColor = 'black'\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tid: shape.id,\n\t\t\t\t\t\t\t\ttype: shape.type,\n\t\t\t\t\t\t\t\tprops,\n\t\t\t\t\t\t\t} as TLShape\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tephemeral\n\t\t\t\t\t)\n\n\t\t\t\t\tif (key !== 'color' && key !== 'opacity') {\n\t\t\t\t\t\tconst changes: TLShapePartial[] = []\n\n\t\t\t\t\t\tfor (const shape of shapes) {\n\t\t\t\t\t\t\tconst currentShape = this.getShapeById(shape.id)\n\t\t\t\t\t\t\tif (!currentShape) continue\n\t\t\t\t\t\t\tconst util = this.getShapeUtil(currentShape)\n\n\t\t\t\t\t\t\tconst boundsA = util.bounds(shape)\n\t\t\t\t\t\t\tconst boundsB = util.bounds(currentShape)\n\n\t\t\t\t\t\t\tconst change: TLShapePartial = { id: shape.id, type: shape.type }\n\n\t\t\t\t\t\t\tlet didChange = false\n\n\t\t\t\t\t\t\tif (boundsA.width !== boundsB.width) {\n\t\t\t\t\t\t\t\tdidChange = true\n\n\t\t\t\t\t\t\t\tif (TLTextShapeDef.is(shape)) {\n\t\t\t\t\t\t\t\t\tswitch (shape.props.align) {\n\t\t\t\t\t\t\t\t\t\tcase 'middle': {\n\t\t\t\t\t\t\t\t\t\t\tchange.x = currentShape.x + (boundsA.width - boundsB.width) / 2\n\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcase 'end': {\n\t\t\t\t\t\t\t\t\t\t\tchange.x = currentShape.x + boundsA.width - boundsB.width\n\t\t\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tchange.x = currentShape.x + (boundsA.width - boundsB.width) / 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (boundsA.height !== boundsB.height) {\n\t\t\t\t\t\t\t\tdidChange = true\n\t\t\t\t\t\t\t\tchange.y = currentShape.y + (boundsA.height - boundsB.height) / 2\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (didChange) {\n\t\t\t\t\t\t\t\tchanges.push(change)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (changes.length) {\n\t\t\t\t\t\t\tthis.updateShapes(changes, ephemeral)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.updateInstanceState(\n\t\t\t\t{\n\t\t\t\t\tpropsForNextShape: setPropsForNextShape(this.instanceState.propsForNextShape, {\n\t\t\t\t\t\t[key]: value,\n\t\t\t\t\t}),\n\t\t\t\t},\n\t\t\t\tephemeral,\n\t\t\t\tsquashing\n\t\t\t)\n\t\t})\n\n\t\treturn this\n\t}\n\n\t_willSetInitialBounds = true\n\n\t/**\n\t * Set the current screen bounds.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setScreenBounds({ x: 0, y: 0, w: 1080, y: 720 })\n\t * \tapp.setScreenBounds({ x: 0, y: 0, w: 1080, y: 720 }, true)\n\t * ```\n\t *\n\t * @param screenBounds - A box model representing the current bounding box of the canvas in screen\n\t *   page.\n\t * @param center - Whether to preserve the same center. Defaults to false.\n\t * @public\n\t */\n\tsetScreenBounds = (rect: Box2dModel, center = false) => {\n\t\tconst screenBounds = Box2d.From(rect)\n\t\tscreenBounds.minX = Math.max(0, screenBounds.minX)\n\t\tscreenBounds.minY = Math.max(0, screenBounds.minY)\n\t\tscreenBounds.w = Math.max(1, screenBounds.width)\n\t\tscreenBounds.h = Math.max(1, screenBounds.height)\n\n\t\tconst boundsAreEqual = screenBounds.equals(this.screenBounds)\n\n\t\t// Get the current value\n\t\tconst { _willSetInitialBounds } = this\n\n\t\tif (boundsAreEqual) {\n\t\t\tthis._willSetInitialBounds = false\n\t\t} else {\n\t\t\tif (_willSetInitialBounds) {\n\t\t\t\t// If we have just received the initial bounds, don't center the camera.\n\t\t\t\tthis._willSetInitialBounds = false\n\t\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson() }, false, true)\n\t\t\t} else {\n\t\t\t\tconst { zoomLevel } = this\n\t\t\t\tif (center) {\n\t\t\t\t\tconst before = this.pageCenter\n\t\t\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson() }, false, true)\n\t\t\t\t\tconst after = this.pageCenter\n\t\t\t\t\tthis.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel)\n\t\t\t\t} else {\n\t\t\t\t\tconst before = this.screenToPage(0, 0)\n\t\t\t\t\tthis.updateInstanceState({ screenBounds: screenBounds.toJson() }, false, true)\n\t\t\t\t\tconst after = this.screenToPage(0, 0)\n\t\t\t\t\tthis.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._cameraManager.tick()\n\t\tthis.updateCullingViewport()\n\n\t\tconst { editingId } = this\n\n\t\tif (editingId) {\n\t\t\tthis.panZoomIntoView([editingId])\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current camera (but doesn't cancel any animation)\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp._setCamera(0, 0, 1)\n\t * ```\n\t *\n\t * @param x - The camera's x position.\n\t * @param y - The camera's y position.\n\t * @param z - The camera's z position. Defaults to the current zoom.\n\t */\n\tprivate _setCamera = (x: number, y: number, z = this.camera.z) => {\n\t\tconst currentCamera = this.camera\n\t\tif (currentCamera.x === x && currentCamera.y === y && currentCamera.z === z) return this\n\t\tthis.store.put([{ ...currentCamera, x, y, z }])\n\n\t\tthis._cameraManager.tick()\n\n\t\tthis.emit('change-camera', this.camera)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the current camera.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.setCamera(0, 0)\n\t * \tapp.setCamera(0, 0, 1)\n\t * ```\n\t *\n\t * @param x - The camera's x position.\n\t * @param y - The camera's y position.\n\t * @param z - The camera's z position. Defaults to the current zoom.\n\t */\n\tsetCamera = (x: number, y: number, z = this.camera.z) => {\n\t\tthis.stopCameraAnimation()\n\t\tx = Number.isNaN(x) ? 0 : x\n\t\ty = Number.isNaN(y) ? 0 : y\n\t\tz = Number.isNaN(z) ? 1 : z\n\t\tthis._setCamera(x, y, z)\n\t\treturn this\n\t}\n\n\t/**\n\t * Animate the camera.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.animateCamera(0, 0)\n\t * \tapp.animateCamera(0, 0, 1)\n\t * \tapp.animateCamera(0, 0, 1, { duration: 1000, easing: (t) => t * t })\n\t * ```\n\t *\n\t * @param x - The camera's x position.\n\t * @param y - The camera's y position.\n\t * @param z - The camera's z position. Defaults to the current zoom.\n\t * @param opts - Options for the animation.\n\t */\n\tanimateCamera = (\n\t\tx: number,\n\t\ty: number,\n\t\tz = this.camera.z,\n\t\topts: AnimationOptions = DEFAULT_ANIMATION_OPTIONS\n\t) => {\n\t\tx = Number.isNaN(x) ? 0 : x\n\t\ty = Number.isNaN(y) ? 0 : y\n\t\tz = Number.isNaN(z) ? 1 : z\n\t\tconst { width, height } = this.screenBounds\n\t\tconst w = width / z\n\t\tconst h = height / z\n\n\t\tconst targetViewport = new Box2d(-x, -y, w, h)\n\n\t\treturn this._animateToViewport(targetViewport, opts)\n\t}\n\n\t/**\n\t * Center the camera on a point (in page space).\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.centerOnPoint(100, 100)\n\t * ```\n\t *\n\t * @param x - The x position of the point.\n\t * @param y - The y position of the point.\n\t * @param opts - The options for an animation.\n\t * @public\n\t */\n\tcenterOnPoint = (x: number, y: number, opts?: AnimationOptions) => {\n\t\tconst { viewport, camera } = this\n\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(-(x - viewport.width / 2), -(y - viewport.height / 2), camera.z, opts)\n\t\t} else {\n\t\t\tthis.setCamera(-(x - viewport.width / 2), -(y - viewport.height / 2), camera.z)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit the current page's content in the viewport.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.zoomToFit()\n\t * ```\n\t *\n\t * @public\n\t */\n\tzoomToFit = (opts?: AnimationOptions) => {\n\t\tconst ids = [...this.shapeIds]\n\t\tif (ids.length <= 0) return\n\n\t\tconst pageBounds = Box2d.Common(compact(ids.map(this.getPageBoundsById)))\n\t\tthis.zoomToBounds(\n\t\t\tpageBounds.minX,\n\t\t\tpageBounds.minY,\n\t\t\tpageBounds.width,\n\t\t\tpageBounds.height,\n\t\t\tundefined,\n\t\t\topts\n\t\t)\n\t\treturn this\n\t}\n\n\t/**\n\t * Set the zoom back to 100%.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.resetZoom()\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t * @public\n\t */\n\tresetZoom = (point = this.screenCenter, opts?: AnimationOptions) => {\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\t\tconst { x, y } = point\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(cx + (x / 1 - x) - (x / cz - x), cy + (y / 1 - y) - (y / cz - y), 1, opts)\n\t\t} else {\n\t\t\tthis.setCamera(cx + (x / 1 - x) - (x / cz - x), cy + (y / 1 - y) - (y / cz - y), 1)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera in.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.zoomIn()\n\t * \tapp.zoomIn(app.screenCenter, { duration: 120 })\n\t * \tapp.zoomIn(app.inputs.currentScreenPoint, { duration: 120 })\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t * @public\n\t */\n\tzoomIn = (point = this.screenCenter, opts?: AnimationOptions) => {\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\tlet zoom = MAX_ZOOM\n\n\t\tfor (let i = 1; i < ZOOMS.length; i++) {\n\t\t\tconst z1 = ZOOMS[i - 1]\n\t\t\tconst z2 = ZOOMS[i]\n\t\t\tif (z2 - cz <= (z2 - z1) / 2) continue\n\t\t\tzoom = z2\n\t\t\tbreak\n\t\t}\n\n\t\tconst { x, y } = point\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(\n\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\tzoom,\n\t\t\t\topts\n\t\t\t)\n\t\t} else {\n\t\t\tthis.setCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera out.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.zoomOut()\n\t * \tapp.zoomOut(app.screenCenter, { duration: 120 })\n\t * \tapp.zoomOut(app.inputs.currentScreenPoint, { duration: 120 })\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t * @public\n\t */\n\tzoomOut = (point = this.screenCenter, opts?: AnimationOptions) => {\n\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\n\t\tlet zoom = MIN_ZOOM\n\n\t\tfor (let i = ZOOMS.length - 1; i > 0; i--) {\n\t\t\tconst z1 = ZOOMS[i - 1]\n\t\t\tconst z2 = ZOOMS[i]\n\t\t\tif (z2 - cz >= (z2 - z1) / 2) continue\n\t\t\tzoom = z1\n\t\t\tbreak\n\t\t}\n\n\t\tconst { x, y } = point\n\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(\n\t\t\t\tcx + (x / zoom - x) - (x / cz - x),\n\t\t\t\tcy + (y / zoom - y) - (y / cz - y),\n\t\t\t\tzoom,\n\t\t\t\topts\n\t\t\t)\n\t\t} else {\n\t\t\tthis.setCamera(cx + (x / zoom - x) - (x / cz - x), cy + (y / zoom - y) - (y / cz - y), zoom)\n\t\t}\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit the current selection in the viewport.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.zoomToSelection()\n\t * ```\n\t *\n\t * @param opts - The options for an animation.\n\t * @public\n\t */\n\tzoomToSelection = (opts?: AnimationOptions) => {\n\t\tconst ids = this.selectedIds\n\t\tif (ids.length <= 0) return\n\n\t\tconst selectedBounds = Box2d.Common(compact(ids.map(this.getPageBoundsById)))\n\n\t\tthis.zoomToBounds(\n\t\t\tselectedBounds.minX,\n\t\t\tselectedBounds.minY,\n\t\t\tselectedBounds.width,\n\t\t\tselectedBounds.height,\n\t\t\tMath.max(1, this.camera.z),\n\t\t\topts\n\t\t)\n\t\treturn this\n\t}\n\n\t/**\n\t * Pan or pan/zoom the selected ids into view. This method tries to not\n\t * change the zoom if possible.\n\t *\n\t * @param ids - The ids of the shapes to pan and zoom into view.\n\t * @param opts - The options for an animation.\n\t * @public\n\t */\n\tpanZoomIntoView = (ids: TLShapeId[], opts?: AnimationOptions) => {\n\t\tif (ids.length <= 0) return\n\t\tconst selectedBounds = Box2d.Common(compact(ids.map(this.getPageBoundsById)))\n\n\t\tif (this.pageBounds.h < selectedBounds.h || this.pageBounds.w < selectedBounds.w) {\n\t\t\tthis.zoomToBounds(\n\t\t\t\tselectedBounds.minX,\n\t\t\t\tselectedBounds.minY,\n\t\t\t\tselectedBounds.width,\n\t\t\t\tselectedBounds.height,\n\t\t\t\tthis.camera.z,\n\t\t\t\topts\n\t\t\t)\n\n\t\t\treturn this\n\t\t} else {\n\t\t\t// TODO: This buffer should calculate the 'active area' of the UI\n\t\t\tconst bufferOffsets = this._activeAreaManager.offsets.value\n\n\t\t\tconst pageTop = this.pageBounds.y + bufferOffsets.top\n\t\t\tconst pageLeft = this.pageBounds.x + bufferOffsets.left\n\t\t\tconst pageBottom = this.pageBounds.y + this.pageBounds.h - bufferOffsets.bottom\n\t\t\tconst pageRight = this.pageBounds.x + this.pageBounds.w - bufferOffsets.right\n\n\t\t\tconst selectedTop = selectedBounds.y\n\t\t\tconst selectedLeft = selectedBounds.x\n\t\t\tconst selectedBottom = selectedBounds.y + selectedBounds.h\n\t\t\tconst selectedRight = selectedBounds.x + selectedBounds.w\n\n\t\t\tlet offsetX = 0\n\t\t\tlet offsetY = 0\n\t\t\tif (pageBottom < selectedBottom) {\n\t\t\t\t// off bottom\n\t\t\t\toffsetY = pageBottom - selectedBottom\n\t\t\t} else if (pageTop > selectedTop) {\n\t\t\t\t// off top\n\t\t\t\toffsetY = pageTop - selectedTop\n\t\t\t} else {\n\t\t\t\t// inside y-bounds\n\t\t\t}\n\n\t\t\tif (pageRight < selectedRight) {\n\t\t\t\t// off right\n\t\t\t\toffsetX = pageRight - selectedRight\n\t\t\t} else if (pageLeft > selectedLeft) {\n\t\t\t\t// off left\n\t\t\t\toffsetX = pageLeft - selectedLeft\n\t\t\t} else {\n\t\t\t\t// inside x-bounds\n\t\t\t}\n\n\t\t\tif (opts?.duration) {\n\t\t\t\tthis.animateCamera(this.camera.x + offsetX, this.camera.y + offsetY, this.camera.z, opts)\n\t\t\t} else {\n\t\t\t\tthis.setCamera(this.camera.x + offsetX, this.camera.y + offsetY, this.camera.z)\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Zoom the camera to fit a bounding box (in page space).\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.zoomToBounds(0, 0, 100, 100)\n\t * ```\n\t *\n\t * @param x - The bounding box's x position.\n\t * @param y - The bounding box's y position.\n\t * @param width - The bounding box's width.\n\t * @param height - The bounding box's height.\n\t * @param targetZoom - The desired zoom level. Defaults to 0.1.\n\t * @public\n\t */\n\tzoomToBounds = (\n\t\tx: number,\n\t\ty: number,\n\t\twidth: number,\n\t\theight: number,\n\t\ttargetZoom?: number,\n\t\topts?: AnimationOptions\n\t) => {\n\t\tconst { w: sw, h: sh } = this.screenBounds\n\n\t\tconst inset = Math.min(256, sw * 0.28)\n\n\t\tlet zoom = clamp(Math.min((sw - inset) / width, (sh - inset) / height), MIN_ZOOM, MAX_ZOOM)\n\n\t\tif (targetZoom !== undefined) {\n\t\t\tzoom = Math.min(targetZoom, zoom)\n\t\t}\n\n\t\tif (opts?.duration) {\n\t\t\tthis.animateCamera(\n\t\t\t\t-x + (sw - width * zoom) / 2 / zoom,\n\t\t\t\t-y + (sh - height * zoom) / 2 / zoom,\n\t\t\t\tzoom,\n\t\t\t\topts\n\t\t\t)\n\t\t} else {\n\t\t\tthis.setCamera(\n\t\t\t\t-x + (sw - width * zoom) / 2 / zoom,\n\t\t\t\t-y + (sh - height * zoom) / 2 / zoom,\n\t\t\t\tzoom\n\t\t\t)\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Pan the camera.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.pan(100, 100)\n\t * \tapp.pan(100, 100, {duration: 1000})\n\t * ```\n\t *\n\t * @param dx - The amount to pan on the x axis.\n\t * @param dy - The amount to pan on the y axis.\n\t * @param opts - the animation options\n\t */\n\tpan = (dx: number, dy: number, opts?: AnimationOptions) => {\n\t\tconst { camera } = this\n\t\tconst { x: cx, y: cy, z: cz } = camera\n\t\tconst d = new Vec2d(dx, dy).div(cz)\n\n\t\tif (opts?.duration ?? 0 > 0) {\n\t\t\treturn this.animateCamera(cx + d.x, cy + d.y, cz, opts)\n\t\t} else {\n\t\t\tthis.setCamera(cx + d.x, cy + d.y, cz)\n\t\t}\n\t}\n\n\t/**\n\t * Stop the current camera animation, if any.\n\t *\n\t * @public\n\t */\n\tstopCameraAnimation = () => {\n\t\tthis.emit('stop-camera-animation')\n\t}\n\n\t_viewportAnimation = null as null | {\n\t\telapsed: number\n\t\tduration: number\n\t\teasing: (t: number) => number\n\t\tstart: Box2d\n\t\tend: Box2d\n\t}\n\n\tprivate _animateViewport(ms: number) {\n\t\tif (!this._viewportAnimation) return\n\n\t\tconst cancel = () => {\n\t\t\tthis.removeListener('tick', this._animateViewport)\n\t\t\tthis.removeListener('stop-camera-animation', cancel)\n\t\t}\n\n\t\tthis.once('stop-camera-animation', cancel)\n\n\t\tthis._viewportAnimation.elapsed += ms\n\n\t\tconst { elapsed, easing, duration, start, end } = this._viewportAnimation\n\n\t\tif (elapsed > duration) {\n\t\t\tconst z = this.screenBounds.width / end.width\n\t\t\tconst x = -end.x\n\t\t\tconst y = -end.y\n\n\t\t\tthis._setCamera(x, y, z)\n\t\t\tthis.removeListener('tick', this._animateViewport)\n\t\t\tthis._viewportAnimation = null\n\t\t\treturn\n\t\t}\n\n\t\tconst remaining = duration - elapsed\n\t\tconst t = easing(1 - remaining / duration)\n\n\t\tconst left = start.minX + (end.minX - start.minX) * t\n\t\tconst top = start.minY + (end.minY - start.minY) * t\n\t\tconst right = start.maxX + (end.maxX - start.maxX) * t\n\t\tconst bottom = start.maxY + (end.maxY - start.maxY) * t\n\n\t\tconst easedViewport = new Box2d(left, top, right - left, bottom - top)\n\n\t\tconst z = this.screenBounds.width / easedViewport.width\n\t\tconst x = -easedViewport.x\n\t\tconst y = -easedViewport.y\n\n\t\tthis._setCamera(x, y, z)\n\t}\n\n\tprivate _animateToViewport = (targetViewportPage: Box2d, opts = {} as AnimationOptions) => {\n\t\tconst { duration = 0, easing = EASINGS.easeInOutCubic } = opts\n\t\tconst startViewport = this.viewport.clone()\n\n\t\tthis.stopCameraAnimation()\n\n\t\tthis._viewportAnimation = {\n\t\t\telapsed: 0,\n\t\t\tduration,\n\t\t\teasing,\n\t\t\tstart: startViewport,\n\t\t\tend: targetViewportPage,\n\t\t}\n\n\t\tthis.addListener('tick', this._animateViewport)\n\n\t\treturn this\n\t}\n\n\tslideCamera = (\n\t\topts = {} as {\n\t\t\tspeed: number\n\t\t\tdirection: Vec2d\n\t\t\tfriction: number\n\t\t\tspeedThreshold?: number\n\t\t}\n\t) => {\n\t\tconst { speed, direction, friction, speedThreshold = 0.01 } = opts\n\t\tlet currentSpeed = speed\n\n\t\tthis.stopCameraAnimation()\n\n\t\tconst cancel = () => {\n\t\t\tthis.removeListener('tick', moveCamera)\n\t\t\tthis.removeListener('stop-camera-animation', cancel)\n\t\t}\n\n\t\tthis.once('stop-camera-animation', cancel)\n\n\t\tconst moveCamera = (elapsed: number) => {\n\t\t\tconst { x: cx, y: cy, z: cz } = this.camera\n\t\t\tconst movementVec = direction.clone().mul((currentSpeed * elapsed) / cz)\n\n\t\t\t// Apply friction\n\t\t\tcurrentSpeed *= 1 - friction\n\t\t\tif (currentSpeed < speedThreshold) {\n\t\t\t\tcancel()\n\t\t\t} else {\n\t\t\t\tthis._setCamera(cx + movementVec.x, cy + movementVec.y, cz)\n\t\t\t}\n\t\t}\n\n\t\tthis.addListener('tick', moveCamera)\n\n\t\treturn this\n\t}\n\n\tanimateToShape = (shapeId: TLShapeId, opts: AnimationOptions = DEFAULT_ANIMATION_OPTIONS) => {\n\t\tconst activeArea = getActiveAreaScreenSpace(this)\n\t\tconst viewportAspectRatio = activeArea.width / activeArea.height\n\n\t\tconst shapePageBounds = this.getPageBoundsById(shapeId)\n\t\tif (!shapePageBounds) {\n\t\t\treturn this\n\t\t}\n\n\t\tconst shapeAspectRatio = shapePageBounds.width / shapePageBounds.height\n\n\t\tconst targetViewportPage = shapePageBounds.clone()\n\n\t\tconst z = shapePageBounds.width / activeArea.width\n\t\ttargetViewportPage.width += (activeArea.left + activeArea.right) * z\n\t\ttargetViewportPage.height += (activeArea.top + activeArea.bottom) * z\n\t\ttargetViewportPage.x -= activeArea.left * z\n\t\ttargetViewportPage.y -= activeArea.top * z\n\n\t\tif (shapeAspectRatio > viewportAspectRatio) {\n\t\t\ttargetViewportPage.height = shapePageBounds.width / viewportAspectRatio\n\t\t\ttargetViewportPage.y -= (targetViewportPage.height - shapePageBounds.height) / 2\n\t\t} else {\n\t\t\ttargetViewportPage.width = shapePageBounds.height * viewportAspectRatio\n\t\t\ttargetViewportPage.x -= (targetViewportPage.width - shapePageBounds.width) / 2\n\t\t}\n\n\t\treturn this._animateToViewport(targetViewportPage, opts)\n\t}\n\n\t/**\n\t * Blur the app, cancelling any interaction state.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.blur()\n\t * ```\n\t *\n\t * @public\n\t */\n\tblur = () => {\n\t\tthis.dispatch({ type: 'misc', name: 'blur' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch a cancel event.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.cancel()\n\t * ```\n\t *\n\t * @public\n\t */\n\tcancel = () => {\n\t\tthis.dispatch({ type: 'misc', name: 'cancel' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch an interrupt event.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.interrupt()\n\t * ```\n\t *\n\t * @public\n\t */\n\tinterrupt = () => {\n\t\tthis.dispatch({ type: 'misc', name: 'interrupt' })\n\t\treturn this\n\t}\n\n\t/**\n\t * Dispatch a complete event.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.complete()\n\t * ```\n\t *\n\t * @public\n\t */\n\tcomplete = () => {\n\t\tthis.dispatch({ type: 'misc', name: 'complete' })\n\t\treturn this\n\t}\n\n\t/* -------------------- Callbacks ------------------- */\n\n\t/**\n\t * A callback fired when a file is converted to an asset. This callback should return the asset partial.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.onCreateAssetFromFile(myFile)\n\t * ```\n\t *\n\t * @param file - The file to upload.\n\t * @public\n\t */\n\n\tasync onCreateAssetFromFile(file: File): Promise<TLAsset> {\n\t\treturn await getMediaAssetFromFile(file)\n\t}\n\n\t/**\n\t * A callback fired when a URL is converted to a bookmark. This callback should return the\n\t * metadata for the bookmark.\n\t *\n\t * @example\n\t * ```ts\n\t * \tapp.onCreateBookmarkFromUrl(url, id)\n\t * ```\n\t *\n\t * @param url - The url that was created.\n\t * @public\n\t */\n\tasync onCreateBookmarkFromUrl(\n\t\turl: string\n\t): Promise<{ image: string; title: string; description: string }> {\n\t\ttry {\n\t\t\tconst resp = await fetch(url, { method: 'GET', mode: 'no-cors' })\n\t\t\tconst html = await resp.text()\n\t\t\tconst doc = new DOMParser().parseFromString(html, 'text/html')\n\n\t\t\treturn {\n\t\t\t\timage: doc.head.querySelector('meta[property=\"og:image\"]')?.getAttribute('content') ?? '',\n\t\t\t\ttitle: doc.head.querySelector('meta[property=\"og:title\"]')?.getAttribute('content') ?? '',\n\t\t\t\tdescription:\n\t\t\t\t\tdoc.head.querySelector('meta[property=\"og:description\"]')?.getAttribute('content') ?? '',\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.error(error)\n\t\t\treturn { image: '', title: '', description: '' }\n\t\t}\n\t}\n\n\t/* ---------------- Text Measurement ---------------- */\n\n\t/**\n\t * A helper for measuring text.\n\t *\n\t * @public\n\t */\n\ttextMeasure: TextManager\n\n\t/* --------------------- Groups --------------------- */\n\n\tgroupShapes = (ids: TLShapeId[] = this.selectedIds, groupId = createShapeId()) => {\n\t\tif (this.isReadOnly) return this\n\n\t\tif (ids.length <= 1) return this\n\n\t\tconst shapes = compact(ids.map(this.getShapeById))\n\t\tconst sortedShapeIds = shapes.sort(sortByIndex).map((s) => s.id)\n\t\tconst pageBounds = Box2d.Common(compact(shapes.map(this.getPageBounds)))\n\n\t\tconst { x, y } = pageBounds.point\n\n\t\tconst parentId = this.findCommonAncestor(shapes) ?? this.currentPageId\n\n\t\t// Only group when the select tool is active\n\t\tif (this.currentToolId !== 'select') return this\n\n\t\t// If not already in idle, cancel the current interaction (get back to idle)\n\t\tif (!this.isIn('select.idle')) {\n\t\t\tthis.cancel()\n\t\t}\n\n\t\t// Find all the shapes that have the same parentId, and use the highest index.\n\t\tconst shapesWithRootParent = shapes\n\t\t\t.filter((shape) => shape.parentId === parentId)\n\t\t\t.sort(sortByIndex)\n\n\t\tconst highestIndex = shapesWithRootParent[shapesWithRootParent.length - 1]?.index\n\n\t\tthis.batch(() => {\n\t\t\tthis.createShapes([\n\t\t\t\t{\n\t\t\t\t\tid: groupId,\n\t\t\t\t\ttype: 'group',\n\t\t\t\t\tparentId,\n\t\t\t\t\tindex: highestIndex,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\topacity: '1',\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t])\n\t\t\tthis.reparentShapes(sortedShapeIds, groupId)\n\t\t\tthis.select(groupId)\n\t\t})\n\n\t\treturn this\n\t}\n\n\tungroupShapes = (ids: TLShapeId[] = this.selectedIds) => {\n\t\tif (this.isReadOnly) return this\n\t\tif (ids.length === 0) return this\n\n\t\t// Only ungroup when the select tool is active\n\t\tif (this.currentToolId !== 'select') return this\n\n\t\t// If not already in idle, cancel the current interaction (get back to idle)\n\t\tif (!this.isIn('select.idle')) {\n\t\t\tthis.cancel()\n\t\t}\n\n\t\t// The ids of the selected shapes after ungrouping;\n\t\t// these include all of the grouped shapes children,\n\t\t// plus any shapes that were selected apart from the groups.\n\t\tconst idsToSelect = new Set<TLShapeId>()\n\n\t\t// Get all groups in the selection\n\t\tconst shapes = compact(ids.map(this.getShapeById))\n\n\t\tconst groups: TLGroupShape[] = []\n\n\t\tshapes.forEach((shape) => {\n\t\t\tif (TLGroupShapeDef.is(shape)) {\n\t\t\t\tgroups.push(shape)\n\t\t\t} else {\n\t\t\t\tidsToSelect.add(shape.id)\n\t\t\t}\n\t\t})\n\n\t\tif (groups.length === 0) return this\n\n\t\tthis.batch(() => {\n\t\t\tlet group: TLShape\n\n\t\t\tfor (let i = 0, n = groups.length; i < n; i++) {\n\t\t\t\tgroup = groups[i] as TLGroupShape\n\t\t\t\tconst childIds = this.getSortedChildren(group.id)\n\n\t\t\t\tfor (let j = 0, n = childIds.length; j < n; j++) {\n\t\t\t\t\tidsToSelect.add(childIds[j])\n\t\t\t\t}\n\n\t\t\t\tthis.reparentShapes(childIds, group.parentId, group.index)\n\t\t\t}\n\n\t\t\tthis.deleteShapes(groups.map((group) => group.id))\n\t\t\tthis.select(...idsToSelect)\n\t\t})\n\n\t\treturn this\n\t}\n}\n\nfunction alertMaxShapes(app: App, pageId = app.currentPageId) {\n\tconst name = app.getPageById(pageId)!.name\n\tapp.emit('max-shapes', { name, pageId, count: MAX_SHAPES_PER_PAGE })\n}\n"],
-  "mappings": "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",
-  "names": ["id", "ancestor", "currentScreenPoint", "assets", "animatingShapes", "gap", "shape", "i", "ids", "z", "x", "y", "n", "group"]
-}
diff --git a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/app/statechart/TLSelectTool/TLSelectTool.mjs b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/app/statechart/TLSelectTool/TLSelectTool.mjs
index 185d39d..f19078a 100644
--- a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/app/statechart/TLSelectTool/TLSelectTool.mjs
+++ b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/app/statechart/TLSelectTool/TLSelectTool.mjs
@@ -40,6 +40,7 @@ class TLSelectTool extends StateNode {
   };
 }
 export {
-  TLSelectTool
+  TLSelectTool,
+  DraggingHandle,
 };
 //# sourceMappingURL=TLSelectTool.mjs.map
diff --git a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/hooks/useCanvasEvents.mjs b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/hooks/useCanvasEvents.mjs
index 043e7c0..f480bc6 100644
--- a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/hooks/useCanvasEvents.mjs
+++ b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/hooks/useCanvasEvents.mjs
@@ -78,7 +78,7 @@ function useCanvasEvents() {
         ;
         e.isKilled = true;
         document.body.click();
-        preventDefault(e);
+        // preventDefault(e);
       }
       function onTouchEnd(e) {
         ;
diff --git a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/index.mjs b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/index.mjs
index 57cb723..4be6ebd 100644
--- a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/index.mjs
+++ b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/index.mjs
@@ -3,6 +3,8 @@ export * from "./app/App.mjs";
 export * from "./app/shapeutils/index.mjs";
 export * from "./app/statechart/StateNode.mjs";
 export * from "./app/statechart/TLBoxTool/index.mjs";
+export * from "./app/statechart/TLArrowTool/index.mjs";
+export * from "./app/statechart/TLSelectTool/index.mjs";
 export * from "./app/types/clipboard-types.mjs";
 export * from "./app/types/event-types.mjs";
 export * from "./app/types/history-types.mjs";
diff --git a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/utils/assets.mjs b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/utils/assets.mjs
index bc63c45..8c97b7b 100644
--- a/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/utils/assets.mjs
+++ b/node_modules/@tldraw/tldraw/node_modules/@tldraw/editor/dist/esm/lib/utils/assets.mjs
@@ -54,41 +54,70 @@ async function getResizedImageDataUrl(dataURLForImage, width, height) {
     img.src = dataURLForImage;
   });
 }
+// async function getMediaAssetFromFile(file) {
+//   return await new Promise((resolve, reject) => {
+//     const reader = new FileReader();
+//     reader.onerror = () => reject(reader.error);
+//     reader.onload = async () => {
+//       let dataUrl = reader.result;
+//       const isImageType = isImage(file.type);
+//       const sizeFn = isImageType ? getImageSizeFromSrc : getVideoSizeFromSrc;
+//       if (file.type === "video/quicktime" && dataUrl.includes("video/quicktime")) {
+//         dataUrl = dataUrl.replace("video/quicktime", "video/mp4");
+//       }
+//       const originalSize = await sizeFn(dataUrl);
+//       const size = containBoxSize(originalSize, { w: MAX_ASSET_WIDTH, h: MAX_ASSET_HEIGHT });
+//       if (size !== originalSize && (file.type === "image/jpeg" || file.type === "image/png")) {
+//         dataUrl = await getResizedImageDataUrl(dataUrl, size.w, size.h);
+//       }
+//       const assetId = TLAsset.createCustomId(getHashForString(dataUrl));
+//       const metadata = await getFileMetaData(file);
+//       const asset = {
+//         id: assetId,
+//         type: isImageType ? "image" : "video",
+//         typeName: "asset",
+//         props: {
+//           name: file.name,
+//           src: dataUrl,
+//           w: size.w,
+//           h: size.h,
+//           mimeType: file.type,
+//           isAnimated: metadata.isAnimated
+//         }
+//       };
+//       resolve(asset);
+//     };
+//     reader.readAsDataURL(file);
+//   });
+// }
 async function getMediaAssetFromFile(file) {
-  return await new Promise((resolve, reject) => {
-    const reader = new FileReader();
-    reader.onerror = () => reject(reader.error);
-    reader.onload = async () => {
-      let dataUrl = reader.result;
-      const isImageType = isImage(file.type);
-      const sizeFn = isImageType ? getImageSizeFromSrc : getVideoSizeFromSrc;
-      if (file.type === "video/quicktime" && dataUrl.includes("video/quicktime")) {
-        dataUrl = dataUrl.replace("video/quicktime", "video/mp4");
-      }
-      const originalSize = await sizeFn(dataUrl);
-      const size = containBoxSize(originalSize, { w: MAX_ASSET_WIDTH, h: MAX_ASSET_HEIGHT });
-      if (size !== originalSize && (file.type === "image/jpeg" || file.type === "image/png")) {
-        dataUrl = await getResizedImageDataUrl(dataUrl, size.w, size.h);
-      }
-      const assetId = TLAsset.createCustomId(getHashForString(dataUrl));
-      const metadata = await getFileMetaData(file);
-      const asset = {
-        id: assetId,
-        type: isImageType ? "image" : "video",
-        typeName: "asset",
-        props: {
-          name: file.name,
-          src: dataUrl,
-          w: size.w,
-          h: size.h,
-          mimeType: file.type,
-          isAnimated: metadata.isAnimated
-        }
-      };
-      resolve(asset);
-    };
-    reader.readAsDataURL(file);
+  const url = await window.roamAlphaAPI.file.upload({
+    file, 
+    toast: {
+      hide: true
+    }
   });
+  const dataUrl = url.replace(/^!\[\]\(/, "").replace(/\)$/, "");
+  const isImageType = isImage(file.type);
+  const sizeFn = isImageType ? getImageSizeFromSrc : getVideoSizeFromSrc;
+  const originalSize = await sizeFn(dataUrl);
+  const size = containBoxSize(originalSize, { w: MAX_ASSET_WIDTH, h: MAX_ASSET_HEIGHT });
+  const assetId = TLAsset.createCustomId(getHashForString(dataUrl));
+  const metadata = await getFileMetaData(file);
+  const asset = {
+    id: assetId,
+    type: isImageType ? "image" : "video",
+    typeName: "asset",
+    props: {
+      name: file.name,
+      src: dataUrl,
+      w: size.w,
+      h: size.h,
+      mimeType: file.type,
+      isAnimated: metadata.isAnimated
+    }
+  };
+  return asset;
 }
 async function getFileMetaData(file) {
   if (file.type === "image/gif") {
